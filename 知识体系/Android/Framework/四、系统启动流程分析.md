# 四、系统启动流程分析

作为一名 Android 程序员，你有没有想过：那么复杂的 Android 系统，它是怎样运行起来的，我们的 App 又是怎样被 Android 系统加载后呈现在屏幕上的呢？Android 系统的启动是一个比较复杂的过程，涉及到了一些我们没有接触过的知识，本文将基于 Android Nougat 最新的代码上讲述 Android 系统的启动流程。

### Bootloader —— 第一个程序

当按下电源键（加电）或者系统重启（复位）的时候，引导芯片会从 [ROM](https://zh.wikipedia.org/wiki/%E5%94%AF%E8%AE%80%E8%A8%98%E6%86%B6%E9%AB%94)（这里一般指 Flash ROM，即闪存）中预定义的位置将 Bootloader 载入到 RAM 中，接着，Bootloader 将会把 Linux 内核载入到 RAM 中并启动。

![](static/boxcn5D8hqQ9NwGaHrRDDTx3eUf.)

Bootloader 是在系统内核运行之前运行的一段小程序，也是系统运行的第一个程序，它的主要作用是：

1. 初始化 [RAM](https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8)（一般指内存）
2. 初始化硬件设备
3. 加载内核和内存空间影像图
4. 跳转到内核

### init 进程 —— 1 号进程

Linux 内核启动过程中会创建 init 进程，init 进程是用户空间的第一个进程（pid=1），对应的可执行程序的源文件文件为 [/system/core/init/Init.cpp]([https://android.googlesource.com/platform/system/core/](https://android.googlesource.com/platform/system/core/) /nougat-release/init/init.cpp)，它的 main 方法如下：

```c++
int main(int argc, char** argv) {
    if (!strcmp(basename(argv[0]), "ueventd")) {
        return ueventd_main(argc, argv);
    }
    if (!strcmp(basename(argv[0]), "watchdogd")) {
        return watchdogd_main(argc, argv);
    }
    umask(0);
    add_environment("PATH", _PATH_DEFPATH);
    bool is_first_stage = (argc == 1) || (strcmp(argv[1], "--second-stage") != 0);
    // 创建文件并挂载
    if (is_first_stage) {
        mount("tmpfs", "/dev", "tmpfs", MS_NOSUID, "mode=0755");
        mkdir("/dev/pts", 0755);
        mkdir("/dev/socket", 0755);
        mount("devpts", "/dev/pts", "devpts", 0, NULL);
        #define MAKE_STR(x) __STRING(x)
        mount("proc", "/proc", "proc", 0, "hidepid=2,gid=" MAKE_STR(AID_READPROC));
        mount("sysfs", "/sys", "sysfs", 0, NULL);
    }
    open_devnull_stdio();
    klog_init();
    klog_set_level(KLOG_NOTICE_LEVEL);
    NOTICE("init %s started!\n", is_first_stage ? "first stage" : "second stage");
    if (!is_first_stage) {
        // Indicate that booting is in progress to background fw loaders, etc.
        close(open("/dev/.booting", O_WRONLY | O_CREAT | O_CLOEXEC, 0000));
        // 初始化属性相关资源
        property_init();
        process_kernel_dt();
        process_kernel_cmdline();
        export_kernel_boot_props();
    }
    ...
    // 启动属性服务
    start_property_service();
    const BuiltinFunctionMap function_map;
    Action::set_function_map(&function_map);
    Parser& parser = Parser::GetInstance();
    parser.AddSectionParser("service",std::make_unique<ServiceParser>());
    parser.AddSectionParser("on", std::make_unique<ActionParser>());
    parser.AddSectionParser("import", std::make_unique<ImportParser>());
    // 解析init.rc配置文件
    parser.ParseConfig("/init.rc");
    ...   
    while (true) {
        if (!waiting_for_exec) {
            am.ExecuteOneCommand();
            restart_processes();
        }
        int timeout = -1;
        if (process_needs_restart) {
            timeout = (process_needs_restart - gettime()) * 1000;
            if (timeout < 0)
                timeout = 0;
        }
        if (am.HasMoreCommands()) {
            timeout = 0;
        }
        bootchart_sample(&timeout);
        epoll_event ev;
        int nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &ev, 1, timeout));
        if (nr == -1) {
            ERROR("epoll_wait failed: %s\n", strerror(errno));
        } else if (nr == 1) {
            ((void (*)()) ev.data.ptr)();
        }
    }
    return 0;
}
```

init 进程的职责主要有四个：

1. 解析和运行所有 init.rc 文件
2. 生成设备驱动节点
3. 处理子进程的终结
4. 提供属性服务

这里重点看第一点，[init.rc]([https://android.googlesource.com/platform/system/core/](https://android.googlesource.com/platform/system/core/) /nougat-release/rootdir/init.rc) 是一个配置文件，它由 Android 初始化语言编写，zygote 进程和 servicemanager 进程都是由 init 进程解析 init.rc 中特定的语句启动的，比如，启动 zygote 进程的代码格式如下：

```plain text
service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server
    class main
    socket zygote stream 660 root system
    onrestart write /sys/android_power/request_state wake
    onrestart write /sys/power/state on
    onrestart restart audioserver
    onrestart restart cameraserver
    onrestart restart media
    onrestart restart netd
    writepid /dev/cpuset/foreground/tasks /dev/stune/foreground/tasks
```

事实上，在 [system/core/rootdir]([https://android.googlesource.com/platform/system/core/](https://android.googlesource.com/platform/system/core/) /nougat-release/rootdir) 目录下，有多个 init.rc 文件，在不同的硬件环境下，相应的 init.rc 文件会被导入，比如在 64 位操作系统中，上面启动 zygote 进程的代码是从 [init.zygote64.rc]([https://android.googlesource.com/platform/system/core/](https://android.googlesource.com/platform/system/core/) /nougat-release/rootdir/init.zygote64.rc) 文件中导入的。它的含义主要为：

1. service zygote 表示启动一个名为 zygote 的服务
2. /system/bin/app_process64 表示服务对应执行文件的路径
3. -Xzygote /system/bin --zygote --start-system-server 表示启动服务的参数

### servicemanager 进程 —— Binder 服务的总管

我在文章 [Binder 机制分析](https://ywue4d2ujm.feishu.cn/docs/doccnnNIKMdICh9atjwTbBRYxpf#)中讲到“Binder 通信模型和通信过程”的时候提到过 ServerManager，它是 Binder IPC 的核心，是上下文的管理者，Binder 服务端必须先向 ServerManager 注册才能够为客户端提供服务，Binder 客户端在与服务端通信之前需要从 ServerManager 中查找并获取 Binder 服务端的引用。然而 ServerManager 在向 Binder 驱动申请成为上下文管理者的时候又涉及到了 Binder IPC 过程，这时候应该怎么处理呢？

servicemanager 进程是由 init 进程通过解析 init.rc 文件来启动的，对应的代码如下：

```
service servicemanager /system/bin/servicemanager
    class core
    user system
    group system
    critical
    onrestart restart healthd
    onrestart restart zygote
    onrestart restart media
    onrestart restart surfaceflinger
    onrestart restart drm
```

servicemanager 进程对应可执行程序的源文件为 [framework/native/cmds/servicemanager/service_manager.c]([https://android.googlesource.com/platform/frameworks/native/](https://android.googlesource.com/platform/frameworks/native/) /nougat-release/cmds/servicemanager/service_manager.c)，简化后的代码如下：

```c
int main(int argc, char **argv) {
    struct binder_state *bs;
    // 打开binder驱动，申请 128k 字节大小的内存空间
    bs = binder_open(128*1024);
    ...

    // 成为上下文管理者
    if (binder_become_context_manager(bs)) {
        return -1;
    }

    // 验证 selinux 权限，判断进程是否有权注册或查看指定服务
    selinux_enabled = is_selinux_enabled();
    sehandle = selinux_android_service_context_handle();
    selinux_status_open(true);

    if (selinux_enabled > 0) {
        if (sehandle == NULL) {  
            abort();
        }
        if (getcon(&service_manager_context) != 0) {
            abort();
        }
    }
    ...

    // 进入无限循环，处理 client 端发来的请求 
    binder_loop(bs, svcmgr_handler);
    return 0;
}
```

这里重点关注两点，首先，在申请了一块大小为 128k 的内存空间并验证 selinux 权限后，接着调用 [framework/native/cmds/servicemanager/binder.c]([https://android.googlesource.com/platform/frameworks/native/](https://android.googlesource.com/platform/frameworks/native/) /nougat-release/cmds/servicemanager/binder.c) 中的 binder_become_context_manager 方法：

```c
int binder_become_context_manager(struct binder_state *bs) {
    // 通过ioctl，发送 BINDER_SET_CONTEXT_MGR 指令
    return ioctl(bs->fd, BINDER_SET_CONTEXT_MGR, 0);
}
```

然后，调用 binder_loop 方法进入循环来处理 client 发来的请求，注意第二个参数是一个方法体，用于处理各种状态回调：

```c
int svcmgr_handler(struct binder_state *bs,
                   struct binder_transaction_data *txn,
                   struct binder_io *msg,
                   struct binder_io *reply)
{
    struct svcinfo *si;
    uint16_t *s;
    size_t len;
    uint32_t handle;
    uint32_t strict_policy;
    int allow_isolated;
    ...
    
    strict_policy = bio_get_uint32(msg);
    s = bio_get_string16(msg, &len);
    ...

    switch(txn->code) {
    case SVC_MGR_GET_SERVICE:
    case SVC_MGR_CHECK_SERVICE: 
        // 获取服务名
        s = bio_get_string16(msg, &len); 
        // 根据名称查找相应服务
        handle = do_find_service(bs, s, len, txn->sender_euid, txn->sender_pid);
        bio_put_ref(reply, handle);
        return 0;

    case SVC_MGR_ADD_SERVICE: 
        // 获取服务名
        s = bio_get_string16(msg, &len);
        handle = bio_get_ref(msg);
        allow_isolated = bio_get_uint32(msg) ? 1 : 0;
         // 注册指定服务
        if (do_add_service(bs, s, len, handle, txn->sender_euid,
            allow_isolated, txn->sender_pid))
            return -1;
        break;
    }
}
```

servicemanager 进程在启动过程的工作内容如下：

1. 调用 binder_open 方法打开 Binder 驱动，并申请分配一块 128k 的内存空间
2. 调用 binder_become_context_manager 方法发送 BINDER_SET_CONTEXT_MGR 给 Binder 驱动，使自己成为上下文管理者
3. 验证 selinux 权限，判断进程是否有注册或查看指定服务的权限
4. 调用 binder_loop 方法进入循环状态，等待 Client 请求
5. 根据服务名称注册服务·
6. 接收 Binder 死亡通知

![](static/boxcnu4IQLcO4EURXi7xO1Ujq2d.)

### zygote 进程 —— Java 进程的始祖

#### 1.启动 Java 虚拟机

通过解析 init.rc 文件，zygote 进程对应的可执行程序的源文件为 [frameworks/base/cmds/app_process/app_main.cpp]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/cmds/app_process/app_main.cpp)，它的 main 方法如下：

```c++
int main(int argc, char* const argv[])
{
    ...
    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));
    ...
    // Parse runtime arguments.  Stop at first unrecognized option.
    bool zygote = false;
    bool startSystemServer = false;
    bool application = false;
    String8 niceName;
    String8 className;
    
    ++i;  // Skip unused "parent dir" argument.
    while (i < argc) {
        const char* arg = argv[i++];
        if (strcmp(arg, "--zygote") == 0) {
            // 当前进程是否用于承载 zygote
            zygote = true;
            niceName = ZYGOTE_NICE_NAME;
        } else if (strcmp(arg, "--start-system-server") == 0) { 
            // 是否需要启动 system_server 进程
            startSystemServer = true;
        } else if (strcmp(arg, "--application") == 0) {
            // 启动进入独立的程序模式
            application = true;
        } else if (strncmp(arg, "--nice-name=", 12) == 0) {
            // 此进程的别名
            niceName.setTo(arg + 12);
        } else if (strncmp(arg, "--", 2) != 0) {
            className.setTo(arg);
            break;
        } else {
            --i;
            break;
        }
    }
    
    ...
    
    if (zygote) {
        // 调用 AppRuntime 父类 AndroidRuntime 的 start 方法创建 zygote 进程
        runtime.start("com.android.internal.os.ZygoteInit", args, zygote);
    } else if (className) {
        runtime.start("com.android.internal.os.RuntimeInit", args, zygote);
    } else {
        fprintf(stderr, "Error: no class name or --zygote supplied.\n");
        app_usage();
        LOG_ALWAYS_FATAL("app_process: no class name or --zygote supplied.");
        return 10;
    }
}
```

在我们的场景中， init.rc 指定了 --zygote 选项，结合以上代码的注释可知，app_process64 接下来将启动 “ZygoteInit” 并传入 “start-system-server” 作为参数。

之后 ZygoteInit 将会运行于 Java 虚拟机上——因为 runtime 变量实际上就是一个 AndroidRuntime 对象， [frameworks/base/core/jni/AndroidRuntime.cpp]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/core/jni/AndroidRuntime.cpp) 的 start 方法如下：

```c++
void AndroidRuntime::start(const char* className, const Vector<String8>& options, bool zygote)
{
    ...
    /* start the virtual machine */
    JniInvocation jni_invocation;
    jni_invocation.Init(NULL);
    JNIEnv* env;
    // 启动 DVM
    if (startVm(&mJavaVM, &env, zygote) != 0) {
        return;
    }
    // 虚拟机启动后的回调
    onVmCreated(env);
    // 注册 JNI 方法
    if (startReg(env) < 0) {
        ALOGE("Unable to register all android natives\n");
        return;
    }
    jclass stringClass;
    jobjectArray strArray;
    jstring classNameStr;

    stringClass = env->FindClass("java/lang/String");
    assert(stringClass != NULL);
    // 创建数组
    strArray = env->NewObjectArray(options.size() + 1, stringClass, NULL);
    assert(strArray != NULL);
    // 从 app_main 的 main 函数得知 className 为 com.android.internal.os.ZygoteInit
    classNameStr = env->NewStringUTF(className);
    assert(classNameStr != NULL);
    env->SetObjectArrayElement(strArray, 0, classNameStr);

    for (size_t i = 0; i < options.size(); ++i) {
        jstring optionsStr = env->NewStringUTF(options.itemAt(i).string());
        assert(optionsStr != NULL);
        env->SetObjectArrayElement(strArray, i + 1, optionsStr);
    }
    char* slashClassName = toSlashClassName(className);
    jclass startClass = env->FindClass(slashClassName);
    if (startClass == NULL) {
        ALOGE("JavaVM unable to locate class '%s'\n", slashClassName);
        /* keep going */
    } else {
        // 找到 ZygoteInit 的 main 函数
        jmethodID startMeth = env->GetStaticMethodID(startClass, "main",
            "([Ljava/lang/String;)V");
        if (startMeth == NULL) {
            ALOGE("JavaVM unable to find main() in '%s'\n", className);
            /* keep going */
        } else {
            // 通过 JNI 调用 ZygoteInit 的 main 函数
            env->CallStaticVoidMethod(startClass, startMeth, strArray);
            if (env->ExceptionCheck())
                threadExitUncaughtException(env);
        }
    }
  ...
}
```

#### 2.加载 ZygoteInit

通过 JNI 的方式进入 [frameworks/base/core/java/com/android/internal/os/ZygoteInit.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/core/java/com/android/internal/os/ZygoteInit.java)：

```java
public static void main(String argv[]) {
    ...
    try {
        ...       
        // 注册Zygote用的Socket
        registerZygoteSocket(socketName);
        ...
        // 预加载类和资源
        preload();//2
        ...
        if (startSystemServer) {
            // 启动SystemServer进程
            startSystemServer(abiList, socketName);
        }
        Log.i(TAG, "Accepting command socket connections");
        // 等待客户端请求
        runSelectLoop(abiList);
        closeServerSocket();
    } catch (MethodAndArgsCaller caller) {
        caller.run();
    } catch (RuntimeException ex) {
        Log.e(TAG, "Zygote died with exception", ex);
        closeServerSocket();
        throw ex;
    }
}
```

##### 1.注册一个 Socket

registerZygoteSocket 方法：

```java
private static void registerZygoteSocket(String socketName) {
    if (sServerSocket == null) {
        int fileDesc;
        final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;
        try {
            String env = System.getenv(fullSocketName);
            fileDesc = Integer.parseInt(env);
        } catch (RuntimeException ex) {
            throw new RuntimeException(fullSocketName + " unset or invalid", ex);
        }
        try {
            FileDescriptor fd = new FileDescriptor();
            fd.setInt$(fileDesc);
            // 创建 Socket 客户端
            sServerSocket = new LocalServerSocket(fd);
        } catch (IOException ex) {
            throw new RuntimeException(
                "Error binding to local socket '" + fileDesc + "'", ex);
        }
    }
}
```

##### 2.预加载各类资源

Preload 方法：

```java
static void preload() {
    Log.d(TAG, "begin preload");
    Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "BeginIcuCachePinning");
    beginIcuCachePinning();
    Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
    Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadClasses");
    preloadClasses();
    Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
    Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadResources");
    preloadResources();
    Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
    Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadOpenGL");
    preloadOpenGL();
    Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
    preloadSharedLibraries();
    preloadTextResources();
    // Ask the WebViewFactory to do any initialization that must run in the zygote process,
    // for memory sharing purposes.
    WebViewFactory.prepareWebViewInZygote();
    endIcuCachePinning();
    warmUpJcaProviders();
    Log.d(TAG, "end preload");
}
```

##### 3.启动 system_server 进程

startSystemServer 方法：

```java
private static boolean startSystemServer(String abiList, String socketName)
            throws MethodAndArgsCaller, RuntimeException {
    ...
    /* Hardcoded command line to start the system server */
    // SystemServer 启动参数
    String args[] = {
        "--setuid=1000",
        "--setgid=1000",
        "--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007,3009,3010",
        "--capabilities=" + capabilities + "," + capabilities,
        "--nice-name=system_server",
        "--runtime-args", 
        "com.android.server.SystemServer",
    };
    ZygoteConnection.Arguments parsedArgs = null;

    int pid;

    try {
        parsedArgs = new ZygoteConnection.Arguments(args);
        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);
        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);

        // 调用 Zygote.java fock 出新线程，名字叫 system_server
        pid = Zygote.forkSystemServer(
                parsedArgs.uid, parsedArgs.gid,
                parsedArgs.gids,
                parsedArgs.debugFlags,
                null,
                parsedArgs.permittedCapabilities,
                parsedArgs.effectiveCapabilities);
    } catch (IllegalArgumentException ex) {
        throw new RuntimeException(ex);
    }
    // pid 为 0 则为 fock 出来的子线程
    if (pid == 0) {
        if (hasSecondZygote(abiList)) {
            waitForSecondaryZygote(socketName);
        }
        // 启动 SystemServer 进程
        handleSystemServerProcess(parsedArgs);
    }

    return true;
}
```

首先，拼装启动参数——注意，最后一个选现 --runtime-args 的参数为 <strong>"com.android.server.SystemServer"</strong>，接着会调用 [frameworks/base/core/java/com/android/internal/os/Zygote.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/core/java/com/android/internal/os/Zygote.java) 的 forkSystemServer 方法：

```java
public static int forkSystemServer(int uid, int gid, int[] gids, int debugFlags,
            int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) {
    VM_HOOKS.preFork();
    // 调用 Native 层的方法 fock 出子线程
    int pid = nativeForkSystemServer(
            uid, gid, gids, debugFlags, rlimits, permittedCapabilities, effectiveCapabilities);
    // Enable tracing as soon as we enter the system_server.
    if (pid == 0) {// fock 出来的子线程中执行
        Trace.setTracingEnabled(true);
    }
    VM_HOOKS.postForkCommon();
    return pid;
}
```

通过 nativeForkSystemServer 方法内部调用 nativeForkSystemServer 这个 Native 方法在当前进程中 fork 出一个子进程，随后这个进程会通过 handleSystemServerProcess() 方法来启动各种支撑系统运行的 system_server 进程。

##### 4.开启循环循环等待 fork 进程请求

回头接着看 ZygoteInit.java 流程中的 runSelectLoop 方法：

```java
private static void runSelectLoop(String abiList) throws MethodAndArgsCaller {
    ArrayList<FileDescriptor> fds = new ArrayList<FileDescriptor>();
    ArrayList<ZygoteConnection> peers = new ArrayList<ZygoteConnection>();
    // sServerSocket 对象就是刚才在 registerZygoteSocket 方法中创建的服务端 Socket
    fds.add(sServerSocket.getFileDescriptor());
    peers.add(null);

    // 循环读取状态
    while (true) {
        StructPollfd[] pollFds = new StructPollfd[fds.size()];
        for (int i = 0; i < pollFds.length; ++i) {
            pollFds[i] = new StructPollfd();
            pollFds[i].fd = fds.get(i);
            pollFds[i].events = (short) POLLIN;
        }
        try {
            Os.poll(pollFds, -1);
        } catch (ErrnoException ex) {
            throw new RuntimeException("poll failed", ex);
        }
        for (int i = pollFds.length - 1; i >= 0; --i) {
            // 读取的状态不是客户端连接或者数据请求时，进入下一次循环
            if ((pollFds[i].revents & POLLIN) == 0) {
                continue;
            }
            if (i == 0) {// i = 0 表示跟客户端 Socket 连接上了
                ZygoteConnection newPeer = acceptCommandPeer(abiList);
                peers.add(newPeer);
                fds.add(newPeer.getFileDesciptor());
            } else {// i > 0 表示接收到客户端 Socket 发送过来的请求
                // runOnce 方法创建一个新的应用程序进程
                boolean done = peers.get(i).runOnce();
                if (done) {
                    peers.remove(i);
                    fds.remove(i);
                }
            }
        }
    }
}
```

runSelectLoop 方法的主体是一个 while 死循环，这决定了它作为 zygote 的守护体存在。

[frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/core/java/com/android/internal/os/ZygoteConnection.java) 的 runOnce 方法：

```java
boolean runOnce() throws ZygoteInit.MethodAndArgsCaller {

    String args[];
    Arguments parsedArgs = null;
    FileDescriptor[] descriptors;

    try {
        // 读取 socket 客户端发送过来的参数列表
        args = readArgumentList();
        descriptors = mSocket.getAncillaryFileDescriptors();
    } catch (IOException ex) {
        // EOF reached.
        closeSocket();
        return true;
    }
    ...

    try {
        // 将 socket 客户端传递过来的参数，解析成 Arguments 对象格式
        parsedArgs = new Arguments(args);
        
        ...
        
        // 调用 forkAndSpecialize 方法 fock 出子进程
        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,
                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,
                parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,
                parsedArgs.appDataDir);
    } catch (Exception e) {
        ...
    }

    try {
        if (pid == 0) {
            // 子进程执行
            IoUtils.closeQuietly(serverPipeFd);
            serverPipeFd = null;
            // 进入子进程流程
            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);
            return true;
        } else {
            // 父进程执行
            IoUtils.closeQuietly(childPipeFd);
            childPipeFd = null;
            return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);
        }
    } finally {
        IoUtils.closeQuietly(childPipeFd);
        IoUtils.closeQuietly(serverPipeFd);
    }
}
```

当收到 fork 请求时，首先获取从 socket 客户端传入的参数并存入 parsedArgs 变量，接着在代码块 25 行调用的是 [Zygote.java](https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/com/android/internal/os/Zygote.java) 的 forkAndSpecialize() 方法来 fork 出子进程，从这里开始一分为二，父进程和子进程继续往下执行。

##### 5.子进程执行入口函数

pid==0 表示为子进程这个分支，接着会执行 handleChildProc() 方法并将 parsedArgs 传入：

```java
private void handleChildProc(Arguments parsedArgs,
        FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)
        throws ZygoteInit.MethodAndArgsCaller {
        
     // 关闭 socket
     closeSocket();
     ZygoteInit.closeServerSocket();
     
     ...
     
    if (parsedArgs.niceName != null) {
        Process.setArgV0(parsedArgs.niceName);
    }
    // End of the postFork event.
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    if (parsedArgs.invokeWith != null) {
        WrapperInit.execApplication(parsedArgs.invokeWith,
                parsedArgs.niceName, parsedArgs.targetSdkVersion,
                VMRuntime.getCurrentInstructionSet(),
                pipeFd, parsedArgs.remainingArgs);
    } else {
        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,
                parsedArgs.remainingArgs, null /* classLoader */);
    }
}
```

由于子进程 fork 自 zygote，因此也复制了 zygote 进程的地址空间，因此也会得到 zygote 进程创建的 socket，而这个 socket 对于子进程是无用的，因此需要关闭该 socket。

接着在最后会调用 RuntimeInit 的 zygoteInit 方法并传入 parsedArgs.remainingArgs。这里先不看 zygoteInit 的内容，但是可以剧透一下：后面的一系列流程概括起来就是找到并执行目标进程的入口函数，并执行它的 main 函数。

##### 6.番外：Socket 客户端发送创建进程请求

应用程序启动时，必须要启动一个进程用于承载这个应用，而向 zygote 进程发送 fork 进程请求的则是 ActivityManagerService，简称 AMS：

```java
private final void startProcessLocked(ProcessRecord app, String hostingType,
            String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) {
        {
    ...
    try {
        ...
        // Start the process.  It will either succeed and return a result containing
        // the PID of the new process, or else throw a RuntimeException.
        boolean isActivityProcess = (entryPoint == null);
        if (entryPoint == null) entryPoint = "android.app.ActivityThread";
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "Start proc: " +
                app.processName);
        checkTime(startTime, "startProcess: asking zygote to start proc");
        Process.ProcessStartResult startResult = Process.start(entryPoint,
                app.processName, uid, uid, gids, debugFlags, mountExternal,
                app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,
                app.info.dataDir, entryPointArgs);
        checkTime(startTime, "startProcess: returned from zygote!");
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        ...
    } catch (RuntimeException e) {
        ...
    }
}
```

可以看到，Process.start 方法显示就是去启动一个新的进程以承载业务，而第一个参数 entryPoint 经过兜兜转转最终就是 invokeStaticMain() 方法的 className 参数，entryPoint 的默认值为 "android.app.ActivityThread"。

也就是说，zygote 进程在接到 AMS 请求的时候，会 fork 出一个子进程并且将 ActivityThread 作为入口，而 ActivityThread 就是我们熟知的 Android 应用程序的“主线程”：

```java
public static void main(String[] args) {
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ActivityThreadMain");
    ...
    Looper.prepareMainLooper();
    ActivityThread thread = new ActivityThread();
    thread.attach(false);
    if (sMainThreadHandler == null) {
        sMainThreadHandler = thread.getHandler();
    }
    if (false) {
        Looper.myLooper().setMessageLogging(new
                LogPrinter(Log.DEBUG, "ActivityThread"));
    }
    // End of event ActivityThreadMain.
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    Looper.loop();
    throw new RuntimeException("Main thread loop unexpectedly exited");
}
```

#### 小结

从 App_main 开始，zygote 启动过程的时序图如下：

![](static/boxcn99VUvezATBvZxBaxJIlJZf.jpg)

可以看到，这个过程中 zygote 首先启动了 AndroidRuntime 并通过它反射调用了 ZygoteInit.main() 方法，由此进入了 Java 的世界，因此 zygote 是 Java 层的第一个进程，也是其他 Java 进程的始祖，其他 Java 进程的创建必须依赖 zygote。

zygote 进程的任务分别是：

1. 创建 AppRuntime（继承自 AndroidRuntime）， 并调用它的 <strong>start</strong> 方法
2. 调用 AndroidRuntime 的 <strong>startVM()</strong> 方法创建 DVM（Dalvik Virtual Machine），并调用 <strong>startReg()</strong> 方法为 DVM 注册 JNI
3. 通过 JNI 调用 <strong>ZygoteInit.main()</strong> 方法，第一次进入 Java 的世界
4. 调用 <strong>registerZygoteSocket()</strong> 函数建立 Socket 通道，使 zygote 进程成为 Socket 服务端
5. 调用 <strong>preload()</strong> 方法预加载各种资源
6. 调用 <strong>startSystemServer()</strong> 函数 fock 出 system_server 进程
7. 通过 <strong>runSelectLoop()</strong> 函数等待 ActivityManagerService 发送请求创建新的应用程序进程

### system_server 进程 —— 承载 framework 层核心业务

system_server 进程主要用户创建系统服务，framework 层的 AMS、WMS 和 PMS 等关键服务都是由它创建出来的。

在上一小节中我们已经知道，zygote 进程在启动的过程中会通过 startSystemServer 方法 fock 出了一个叫 system_server 的进程，然后在该方法内执行了 handleSystemServerProcess 方法：

```java
private static void handleSystemServerProcess(
          ZygoteConnection.Arguments parsedArgs)
          throws ZygoteInit.MethodAndArgsCaller {
    /** 这个 Socket 对 system_server 来说同样无用处，这里将其关闭 **/
    closeServerSocket();
    ...
    if (parsedArgs.invokeWith != null) {
        ...
    } else {
        ClassLoader cl = null;
        if (systemServerClasspath != null) {
            cl = createSystemServerClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion);
            Thread.currentThread().setContextClassLoader(cl);
        }
        // 又是调用了它的 zygoteInit 方法
        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);
    }
}
```

这里再次出现了 [RuntimeInit](https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/com/android/internal/os/RuntimeInit.java).zygoteInit() 方法：

```java
public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)
            throws ZygoteInit.MethodAndArgsCaller {
    if (DEBUG) Slog.d(TAG, "RuntimeInit: Starting application from zygote");
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "RuntimeInit");
    redirectLogStreams();
    commonInit();
    // 通过 Native 层中 AndroidRuntime.cpp 的 JNI 方法最终调用 app_main.cpp 
    // 的 onZygoteInit 方法启动 Binder 线程池， 
    // 使 system_server 进程可以使用 Binder 与其他进程通信 
    nativeZygoteInit();
    // 继续往下调用
    applicationInit(targetSdkVersion, argv, classLoader);
}
```

顾名思义，这是一个初始化方法，它将通过三个方面来完成初始化。

首先是 commonInit，通用部分的初始化，包括设置默认的 uncaught exception handler、为 HttpURLConnection 准备好默认的 HTTP User-Agent 等；接着，nativeZygoteInit() 这个是一个 Native 层的初始化方法；最后是 applicatInit()，它是程序运行的起点。

经过这两个过程的初始化后，程序现在会出现两个分支：nativeZygoteInit 主导的 Native 层系统服务启动，以及 applicationInit 负责的 Java 层系统服务的启动。

#### 1.启动 Native 层系统服务

nativeZygoteInit() 是一个 Native 方法，它对应的文件为  [frameworks/base/core/jni/AndroidRuntime.cpp]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/core/jni/AndroidRuntime.cpp)，与该方法对应的函数为：

```c++
static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)
{
    gCurRuntime->onZygoteInit();
}
```

gCurRuntime 是一个 AndroidRuntime 对象全局变量，结合之前的分析可以猜测，AndroidRuntime 是一个父类，真正的实现则在 [frameworks/base/cmds/app_process/app_main.cpp]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/cmds/app_process/app_main.cpp) 中的 AppRuntime 。当新建 AppRuntime 实例时，它的父类构造函数就会被调用并为 gCurRuntime 赋值。上述的 onZygoteInit() 方法也在 app_main 中：

```c++
virtual void onZygoteInit()
{
    sp<ProcessState> proc = ProcessState::self();
    ALOGV("App process: starting thread pool.\n");
    proc->startThreadPool();
}
```

这段代码是 Binder 机制中的重要组成部分，其中 startThreadPool() 方法将开启 Binder 线程池以保证其它线程可以正确访问到 Zygote 启动的服务。Zygote 通过 JNI 和回调的方式非常巧妙地把 Native 层和 Java 层、SystemServe 和 app_process 关联起来了。

#### 2.启动 Java 层系统服务

接着看 RuntimeInit 的 applicationInit() 方法：

```java
private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)
            throws ZygoteInit.MethodAndArgsCaller {
    ...
    invokeStaticMain(args.startClass, args.startArgs, classLoader);
}
```

RuntimeInit 的 invokeStaticMain 方法：

```java
private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)
         throws ZygoteInit.MethodAndArgsCaller {
    Class<?> cl;
    try {
        /** className 为 ZygoteInit.java 中 startSystemServer 方法
        传递过来的 "com.android.server.SystemServer"，这里通过反射得到 SystemServer 类 **/
        cl = Class.forName(className, true, classLoader);
    } catch (ClassNotFoundException ex) {
        throw new RuntimeException(
            "Missing class when invoking static main " + className, ex);
    }
    Method m;
    try {
        // 找到 SystemServer 类的 main 方法
        m = cl.getMethod("main", new Class[] { String[].class });
    } catch (NoSuchMethodException ex) {
        throw new RuntimeException(
            "Missing static main on " + className, ex);
    } catch (SecurityException ex) {
        throw new RuntimeException(
            "Problem getting static main on " + className, ex);
    }
    int modifiers = m.getModifiers();
    if (! (Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers))) {
        throw new RuntimeException(
            "Main method is not public and static on " + className);
    }
    /** 将 main 方法包装在 ZygoteInit.MethodAndArgsCaller 类中并作为异常抛出
    捕获异常的地方在上一小节中 ZygoteInit.java 的 main 方法 **/
    throw new ZygoteInit.MethodAndArgsCaller(m, argv);
}
```

结合注释内容来看捕获这个异常的 [frameworks/base/core/java/com/android/internal/os/ZygoteInit.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/core/java/com/android/internal/os/ZygoteInit.java) 的 main 方法：

```java
public static void main(String argv[]) {
    ...
    closeServerSocket();
    } catch (MethodAndArgsCaller caller) {
        // 接收到 caller 对象后调用它的 run 方法
        caller.run();
    } catch (RuntimeException ex) {
        Log.e(TAG, "Zygote died with exception", ex);
        closeServerSocket();
        throw ex;
    }
}
```

ZygoteInit 的 MethodAndArgsCaller 类是一个 Exception 类，同时也实现了 Runnable 接口：

```java
public static class MethodAndArgsCaller extends Exception
        implements Runnable {
        
    private final Method mMethod;
    private final String[] mArgs;
        
    public MethodAndArgsCaller(Method method, String[] args) {
        mMethod = method;
        mArgs = args;
    }
    public void run() {
        try {
            // 调用传递过来的 mMethod
            mMethod.invoke(null, new Object[] { mArgs });
        } catch (IllegalAccessException ex) {
            throw new RuntimeException(ex);
        } catch (InvocationTargetException ex) {
            ...
        }
    }
}
```

这样，system_server 进程便启动起来并进入了 SystemServer.java 的 main 方法。

这里需要思考一下，为什么需要抛出异常到 ZygoteInit 中执行？官方解释就是抛出异常的时候 Android 虚拟机会清空该进程堆内存中的栈帧，因此前面一系列启动 system_server 进程的过程中方法调用过程就被清除了，节省了堆栈的空间，使 ZygoteInit.java 的 main 方法处于所有 Java 进程的方法栈中的栈顶。

同样地，zygote 进程接收到 AMS 请求并创建进程后，也会执行 ActivityThread 的 main 方法并将其作为 app 进程方法栈中的栈顶。

> 从最新 Android Pie 的代码中看，[ZygoteInit]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /pie-release/core/java/com/android/internal/os/ZygoteInit.java) 中的这个过程从 forkSystemServer() 方法开始，以及 runSelectLoop() 方法，已经变成在每一步中将包装好的 MethodAndArgsCaller 对象作为返回值返回，最后再执行这个对象的 call 方法，这样每个方法都在返回过程被弹出栈帧了，同样达到了以上的效果。

查看 [frameworks/base/services/java/com/android/server/SystemServer.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/services/java/com/android/server/SystemServer.java) 的源码：

```java
/**
 * The main entry point from zygote.
 */
public static void main(String[] args) {
    // 调用 run 方法
    new SystemServer().run();
}
```

```java
private void run() {
    ...
    // 加载 libandroid_servers.so
    System.loadLibrary("android_servers");
    ...
    // 创建 SystemServiceManager
    mSystemServiceManager = new SystemServiceManager(mSystemContext);
    LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);
    ...    
    try {
        Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "StartServices");
        // 启动引导服务
        startBootstrapServices();
        // 启动核心服务
        startCoreServices();
        // 启动其他服务
        startOtherServices();
    } catch (Throwable ex) {
        ...
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    ...
}
```

可以看到，在 run 方法中，主要执行了启动引导服务、核心服务和其他服务的任务，这些服务加起来一共有 80 多个，它们对应这个各种不同的功能，部分服务如下：

| 引导服务               | 作用                                                                           |
| ---------------------- | ------------------------------------------------------------------------------ |
| Installer              | 系统安装 apk 时的一个服务类，启动完成 Installer 服务之后才能启动其他的系统服务 |
| ActivityManagerService | 负责四大组件的启动、切换、调度。                                               |
| PowerManagerService    | 计算系统中和 Power 相关的计算，然后决策系统应该如何反应                        |
| LightsService          | 管理和显示背光 LED                                                             |
| DisplayManagerService  | 用来管理所有显示设备                                                           |
| UserManagerService     | 多用户模式管理                                                                 |
| SensorService          | 为系统提供各种感应器服务                                                       |
| PackageManagerService  | 用来对 apk 进行安装、解析、删除、卸载等等操作                                  |

| 核心服务             | 作用                                    |
| -------------------- | --------------------------------------- |
| BatteryService       | 管理电池相关的服务                      |
| UsageStatsService    | 收集用户使用每一个 APP 的频率、使用时常 |
| WebViewUpdateService | WebView 更新服务                        |

| 其他服务                    | 作用               |
| --------------------------- | ------------------ |
| CameraService               | 摄像头相关服务     |
| AlarmManagerService         | 全局定时器管理服务 |
| InputManagerService         | 管理输入事件       |
| WindowManagerService        | 窗口管理服务       |
| VrManagerService            | VR 模式管理服务    |
| BluetoothService            | 蓝牙管理服务       |
| NotificationManagerService  | 通知管理服务       |
| DeviceStorageMonitorService | 存储相关管理服务   |
| LocationManagerService      | 定位管理服务       |
| AudioService                | 音频相关管理服务   |
| ...                         | ...                |

#### 小结

system_server 进程在启动过程中完成的工作分别是:

1. 通用部分的初始化
2. 启动 Binder 线程池，使进程可以通过 Binder 与其他进程进程通信
3. 创建 SystemServiceManager
4. 使用 SystemServiceManager 对各种系统服务进行创建、启动和生命周期管理

### Launcher —— Android 系统的“桌面”

在上一节 [frameworks/base/services/java/com/android/server/SystemServer.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/services/java/com/android/server/SystemServer.java) 的 main 方法中，有一句：

```java
private void startOtherServices() {
    ...
    // 调用 AMS 的 systemReady 方法
    mActivityManagerService.systemReady(new Runnable() {
        @Override
        public void run() {
            ...
        }
    }
    ...
}
```

继续跟踪：

[frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/services/core/java/com/android/server/am/ActivityManagerService.java)：

```java
public void systemReady(final Runnable goingCallback) {
    ...
    synchronized (this) {
        ...
        // 调用 ActivityStackSupervisor 的 resumeFocusedStackTopActivityLocked 方法
        mStackSupervisor.resumeFocusedStackTopActivityLocked();
        mUserController.sendUserSwitchBroadcastsLocked(-1, currentUserId);
    }
}
```

[frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/services/core/java/com/android/server/am/ActivityStackSupervisor.java)：

```java
boolean resumeFocusedStackTopActivityLocked(ActivityStack targetStack, ActivityRecord target,
        ActivityOptions targetOptions) {
    if (targetStack != null && isFocusedStack(targetStack)) {
        // 调用 ActivityStack 的 resumeTopActivityUncheckedLocked 方法
        return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);
    }
    final ActivityRecord r = mFocusedStack.topRunningActivityLocked();
    if (r == null || r.state != RESUMED) {
        mFocusedStack.resumeTopActivityUncheckedLocked(null, null);
    }
    return false;
}
```

[ActivityStack]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/services/core/java/com/android/server/am/ActivityStack.java)：

```java
boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) {
    if (mStackSupervisor.inResumeTopActivity) {
        return false;
    }

    boolean result = false;
    try {
        // Protect against recursion.
        mStackSupervisor.inResumeTopActivity = true;
        if (mService.mLockScreenShown == ActivityManagerService.LOCK_SCREEN_LEAVING) {
            mService.mLockScreenShown = ActivityManagerService.LOCK_SCREEN_HIDDEN;
            mService.updateSleepIfNeededLocked();
        }
        // 调用 resumeTopActivityInnerLocked 方法
        result = resumeTopActivityInnerLocked(prev, options);
    } finally {
        mStackSupervisor.inResumeTopActivity = false;
    }
    return result;
}
```

```java
private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) {
   ...
   // 回到 ActivityStackSupervisor 的 resumeHomeStackTask 方法
   return isOnHomeDisplay() && mStackSupervisor.resumeHomeStackTask(returnTaskType, prev, "prevFinished");
   ...                 
}
```

[frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/services/core/java/com/android/server/am/ActivityStackSupervisor.java)：

```java
boolean resumeHomeStackTask(int homeStackTaskType, ActivityRecord prev, String reason) {
    ...
    if (r != null && !r.finishing) {
        mService.setFocusedActivityLocked(r, myReason);
        return resumeFocusedStackTopActivityLocked(mHomeStack, prev, null);
    }
    // 再次回到 AMS 的 startHomeActivityLocked 方法
    return mService.startHomeActivityLocked(mCurrentUser, myReason);
}
```

```java
boolean startHomeActivityLocked(int userId, String reason) {
    if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL
            && mTopAction == null) {
        return false;
    }
    // 获取 Intent
    Intent intent = getHomeIntent();
    ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId);
    if (aInfo != null) {
        intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name));
        aInfo = new ActivityInfo(aInfo);
        aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId);
        ProcessRecord app = getProcessRecordLocked(aInfo.processName,
                aInfo.applicationInfo.uid, true);
        if (app == null || app.instrumentationClass == null) {
            intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
            // 使用 mActivityStarter 启动 app，这里不再详细跟踪
            mActivityStarter.startHomeActivityLocked(intent, aInfo, reason);
        }
    } else {
            Slog.wtf(TAG, "No home screen found for " + intent, new Throwable());
    }

    return true;
}
```

getHomeIntent 方法：

```java
Intent getHomeIntent() {
    Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null);
    intent.setComponent(mTopComponent);
    intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING);
    if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        // 添加 android.intent.category.HOME
        intent.addCategory(Intent.CATEGORY_HOME);
    }
    return intent;
}
```

可以看到，最后通过一个隐式 Intent 使用 Intent.FLAG_ACTIVITY_NEW_TASK 模式启动了一个带 Intent.CATEGORY_HOME 标签的 Activity，而带有 Intent.CATEGORY_HOME 标签的 Activity 正是 Launcher App，它的 [AndroidManifest]([https://android.googlesource.com/platform/packages/apps/Launcher3/](https://android.googlesource.com/platform/packages/apps/Launcher3/) /nougat-release/AndroidManifest.xml?autodive=0) 文件如下：

```xml
<manifest
    xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.android.launcher3">
    <uses-sdk android:targetSdkVersion="23" android:minSdkVersion="16"/>
    
    ...
    
    <application
        android:allowBackup="@bool/enable_backup"
        android:backupAgent="com.android.launcher3.LauncherBackupAgentHelper"
        android:hardwareAccelerated="true"
        android:icon="@mipmap/ic_launcher_home"
        android:label="@string/app_name"
        android:largeHeap="@bool/config_largeHeap"
        android:restoreAnyVersion="true"
        android:supportsRtl="true" >
        <activity
            android:name="com.android.launcher3.Launcher"
            android:launchMode="singleTask"
            android:clearTaskOnLaunch="true"
            android:stateNotNeeded="true"
            android:theme="@style/Theme"
            android:windowSoftInputMode="adjustPan"
            android:screenOrientation="nosensor"
            android:configChanges="keyboard|keyboardHidden|navigation"
            android:resumeWhilePausing="true"
            android:taskAffinity=""
            android:enabled="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.HOME" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.MONKEY"/>
            </intent-filter>
        </activity>
        
        ...
        
    </application>
</manifest>
```

Launcher 启动后会将所有已安装的应用图标展示在一个网格布局的 RecyclerView 里面，这时候用户就可以通过点击这些图标来启动相应的 app 了。

这个过程的时序图如下：

![](static/boxcnCiXpwzJ876enoWFzq7eljd.)

关于 Launcher 如何将 App 图标显示出来等更多工作细节，可以参考 [Android M Launcher3 主流程源码浅析](https://blog.csdn.net/yanbober/article/details/50525559) 和 [Android 系统启动流程（四）Launcher 启动过程与系统启动流程](http://liuwangshu.cn/framework/booting/4-launcher.html)这两篇文章。

### 总结

最后，从整体上来看 Android 系统的启动流程：

1. 按下电源，固化在 ROM 中预定位置的 Bootloader 将会被加载到内存中
2. Bootloader 初始化完软硬件环境后将 Linux 内核启动起来
3. Linux 内核启动时会做设置缓存、被保护存储器、计划列表和加载驱动等一些列操作，内核启动完成后会启动 init 进程
4. init 进程会初始化并启动属性服务，并且解析并执行所有 init.rc 文件
5. init 通过执行特定的 init.rc 文件启动 servermanager 进程，servermanager 被启动后会向 Binder 驱动发送命令让自己成为守护进程并管理所有上下文
6. init 通过解析 init.rc 文件启动 zygote 进程
7. zygote 进程启动的过程会创建 DVM 并为其注册 JNI 函数，然后创建服务端 Socket、启动 system_server 进程
8. 启动 system_server 进程的过程会创建 Binder 线程池使其具有 IPC 能力，然后启动 AMS 等各种系统服务
9. AMS 启动 Launcher，Launcher 被启动后会将已安装应用的图标显示在界面上

原来，一个复杂的 Android 系统就这么被运行起来了，碍于本人有限的水平，描述这个过程其实也还简化了很多操作，下面这个图比较全面地总结了这个流程：

![](static/boxcn1cWAytQio9qCfrbczOHPmh.)

<strong>系列文章</strong>

[按下电源键后竟然发生了这一幕 —— Android 系统启动流程分析](https://guanpj.cn/2017/09/17/Android-System-Startup-Flow-Analyze/)（本文）

[App 竟然是这样跑起来的 —— Android App/Activity 启动流程分析](https://guanpj.cn/2017/10/23/Android-App-Startup-Flow-Analyze/)

[屏幕上内容究竟是怎样画出来的 —— Android View 工作原理详解](https://guanpj.cn/2017/11/09/Android-View-Workflow/)

<strong>参考文章</strong>

[Gityuan 大神的系列文章](http://gityuan.com/android/)

[刘望舒老师的系列文章](http://liuwangshu.cn/tags/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/)

[嵌入式系统 Boot Loader 技术内幕](https://www.ibm.com/developerworks/cn/linux/l-btloader/index.html)

> 如果你对文章内容有疑问或者有不同的意见，欢迎留言，我们一同探讨。
