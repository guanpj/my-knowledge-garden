---
title: 计算机网络体系结构、TCP&IP 和 HTTPS
date created: 2023-03-23
date modified: 2023-03-23
dg-publish: true
tags:
  - 计算机网络
  - TCP/IP
  - HTTPS
  - 三次握手
  - 四次挥手
---
# 为什么需要计算机网络体系结构？

计算机网络是个非常复杂的系统。比如，连接在网络上的两台计算机需要进行通信时，由于计算机网络的复杂性和异质性，需要考虑很多复杂的因素，比如：

1. 这两台计算机之间必须有一条传送数据的通路；
2. 告诉网络如何识别接收数据的计算机；
3. 发起通信的计算机必须保证要传送的数据能在这条通路上正确发送和接收；
4. 对出现的各种差错和意外事故，如数据传送错误、网络中某个节点交换机出现故障等问题，应该有可靠完善的措施保证对方计算机最终能正确收到数据。

计算机网络体系结构标准的制定正是为了解决这些问题，要想完成这种网络通信就必须保证相互通信的这两个计算机系统达成<strong>高度默契</strong>。事实上，在网络通信领域，两台计算机(网络设备)之间的通信并不像人与人之间的交流那样自然天然，这种计算机间高度默契的交流(通信) 背后需要十分复杂、完备的网络体系结构作为支撑。那么，用什么方法才能合理地组织网络的结构，以保证其具有结构清晰、设计与实现简化、便于更新和维护、较强的独立性和适应性，从而使网络设备之间具有这种 “高度默契” 呢？答案是分而治之，更进一步地说就是<strong>分层思想</strong>。

# 计算机网络体系结构设计基本思想

## 分层思想在日常生活中的应用

在快递系统中，用户和用户之间的通信依赖于下层的服务，但是他们并不需要关心快递、运输等细节，也就是说，寄信者只需将写好的信交给快递员而收信者只需从快递员手中查收信件即可。类似地，快递员也只需要从寄信人手中拿到信件并交给分检员或将信件从分检员手中拿走并交给收信人即可，至于分检员为何要把这份信交给他进行投递(事实上，每个快递员会负责某个片区，分检员根据收信人地址将信件分发给不同的快递员)，他不需要关心也没必要关心。显然，在这个快递系统中，各个角色（用户、快递员…）在功能上相互独立却又能协调合作达成一种 “高度默契”，这在很大程度上得益于分层思想的理念和应用。

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/TCP%26IP/clipboard_20230323_031033.png)

## 分层思想的优点

1. 耦合度低(独立性强)。上层只需通过下层为上层提供的接口来使用下层所实现的服务，而不需要关心下层的具体实现。也就是说，下层对上层而言就是具有一定功能的黑箱。
2. 适应性强。只要每层为上层提供的服务和接口不变，每层的实现细节可以任意改变。
3. 易于实现和维护。把复杂的系统分解成若干个涉及范围小且功能简单的子单元，从而使得系统结构清晰，实现、调试和维护都变得简单和容易。也就是说，对于设计/开发人员而言，这种方法使设计/开发人员能够专心设计和开发他们所关心的功能模块；对于调试/维护人员而言，这种方法也方便调试/维护人员去处理他们所负责的功能模块。

# 计算机网络体系结构的概念与标准

## 计算机网络体系结构的概念

计算机网络体系结构必须包括三个内容，即分层结构与每层的功能，服务与层间接口和协议。所以，计算机网络体系结构的定义为：<strong>在计算机网络中，层、层间接口及协议的集合。</strong>

## 计算机网络体系结构的标准

目前，由国际化标准组织 ISO 制定的网络体系结构国际标准是 OSI 七层模型，但实际中应用最广泛的是 TCP/IP 体系结构。换句话说，OSI 七层模型只是理论上的、官方制定的国际标准，而<strong>TCP/IP 体系结构才是事实上的国际标准</strong>。这看起来是不可理喻的，但这却是实际存在的，这是由一些历史原因造成的。OSI 标准的制定者以专家、学者为主，他们缺乏实际经验和商业驱动力，并且 OSI 标准自身运行效率也不怎么好。与此同时，由于 Inernet 在全世界覆盖了相当大的范围，并且占领市场的标准是 TCP/IP 体系结构，因此导致 OSI 标准没有市场背景，也就只是理论上的成果，并没有过多地应用于实践。

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/TCP%26IP/clipboard_20230323_031041.png)

# TCP/IP 四层体系结构

TCP/IP 是 Internet 上的标准通信协议集，该协议集由数十个具有层次结构的协议组成，其中 TCP 和 IP 是该协议集中的两个最重要的核心协议。TCP/IP 协议族按层次可分为以下四层：应用层、传输层、网络层和网络接口层，各层对应的 PDU 数据单元的名称如下图所示。

<div style="text-align: center"></div>

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/TCP%26IP/clipboard_20230323_031045.png)

计算机网络体系结构中，对等层之间交换的信息报文统称为<strong>协议数据单元（Protocol Data Unit）</strong>。PDU 由<strong>协议控制信息（协议头）</strong>和<strong>数据（SDU） </strong>组成。

数据封装过程：

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/TCP%26IP/clipboard_20230323_031049.png)

## 应用层

应用层决定了向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务，比如 FTP（文件传输协议）和 DNS（域名系统）服务就是其中两类，HTTP 协议也处于该层。

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/TCP%26IP/clipboard_20230323_031057.png)

## 传输层

传输层对上层应用层提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议：TCP（传输控制协议）和 UDP（用户数据报协议）。其中，TCP 是<strong>面向连接</strong>的传输协议，也就是说，其在数据传输之前会建立连接，并把报文分解为多个段进行传输，在目的站再重新装配这些段，必要时重新传输没有收到或错误的，因此它是“可靠”的。而 UDP 是<strong>无连接</strong>的传输协议，其在数据传输之前不建立连接，并且对发送的段不进行校验和确认，因此它是“不可靠”的。

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/TCP%26IP/clipboard_20230323_031101.png)

## 网络层（网际层）

网络层用来处理在网络上流动的数据包，其中，数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。也就是说，网络层主要功能是把数据报通过最佳路径送到目的端，其中，网际层的核心协议——IP，提供了无连接的数据报传输服务(不保证送达，不保序）。

## 网络接口层

网络接口层用来处理连接网络的硬件部分，包括硬件的设备驱动、NIC（Network Interface Card，网卡）及光纤等物理可见部分，还包括连接器等一切传输媒介。也就是说，硬件上的范畴均在链路层的作用范围之内。

# TCP 连接过程

## 三次握手

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/TCP%26IP/clipboard_20230323_031105.png)

1. 客户端发送的 TCP 报文中标志位 SYN 置 1，初始序号 seq=x（随机选择）。Client 进入 SYN_SENT 状态，等待 Server 确认。
2. 服务器收到数据包后，根据标志位 SYN=1 知道 Client 请求建立连接，Server 将标志位 SYN 和 ACK 都置为 1，ack=x+1，随机产生一个初始序号 seq=y，并将该数据包发送给 Client 以确认连接请求，Server 进入 SYN_RCVD 状态。
3. Client 收到确认后，检查 ack 是否为 x+1，ACK 是否为 1，如果正确则将标志位 ACK 置为 1，ack=y+1，并将该数据包发送给 Server。Server 检查 ack 是否为 y+1，ACK 是否为 1，如果正确则连接建立成功，Client 和 Server 进入 ESTABLISHED 状态，完成三次握手，随后 Client 与 Server 之间可以开始传输数据了。

## 四次挥手

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/TCP%26IP/clipboard_20230323_031108.png)

1. Client 发送一个 FIN，用来关闭 Client 到 Server 的数据传送，Client 进入 FIN_WAIT_1 状态。
2. Server 收到 FIN 后，发送一个 ACK 给 Client，确认序号为 u + 1（与 SYN 相同，一个 FIN 占用一个序号），Server 进入 CLOSE_WAIT 状态。
3. Server 发送一个 FIN，用来关闭 Server 到 Client 的数据传送，Server 进入 LAST_ACK 状态。
4. Client 收到 FIN 后，Client 进入 TIME_WAIT 状态(主动关闭方才会进入该状态）；接着发送一个 ACK 给 Server，确认序号为 w + 1，Server 进入 CLOSED 状态；Client 进入 TIME_WAIT 状态等待 2 MSL(Maximum Segment Lifetime，最大报文生存时间) 后进入 CLOSED 状态。

## 各个符号的含义

ACK、SYN 和 FIN 这些大写的单词表示标志位，其值要么是 1，要么是 0；ack、seq 由小写的单词表示序号。

- 序列号 seq：占 4 个字节，用来标记数据段的顺序，TCP 把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生。给字节编上序号后，就给每一个报文段指派一个序号，序列号 seq 就是这个报文段中的第一个字节的数据编号。
- 确认号 ack：占 4 个字节，表示<strong>期待收到对方下一个报文段的第一个数据字节的序号</strong>；因此当前报文段最后一个字节的编号 +1 即为确认号。
- 确认 ACK：占 1 位，仅当 ACK=1 时，确认号字段才有效。<strong>ACK 报文不需要回复</strong>。
- 同步 SYN：连接建立时用于同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若同意连接，则在响应报文段中使得 SYN=1，ACK=1。因此，SYN=1 表示这是一个连接请求，或连接接受报文。SYN 这个标志位只有在 TCP 建产连接时才会被置 1，握手完成后 SYN 标志位被置 0。<strong>SYN 报文需要回复</strong>。
- 终止 FIN：用来释放一个连接。FIN=1 表示此报文段的发送方的数据已经发送完毕，并要求释放运输连接。<strong>FIN </strong><strong>报文也需要回复</strong>。

# HTTPS

HTTP over SSL 的简称，即⼯作在 SSL/TLS 上的 HTTP。服务端和客户端的信息传输都会通过 SSL/TLS 进行加密，所以传输的数据都是加密后的数据。它的工作原理是在客户端和服务器之间利用非堆成加密，协商出⼀套对称加密的密钥，每次发送信息之前将内容加密，收到之后解密，达到内容的加密传输。

TLS 的前身是 SSL，SSL 1.0 建立在 SSL 3.0 协议规范之上，是 SSL 3.0 的后续版本。TLS 目前最新版本为 TLS 1.2。TLS 和 SSL 协议理论上属于传输层，在应用层实现。

## 为什么需要 HTTPS？

HTTP 使用明文传输，面临的风险有：

1. 窃听风险：黑客可以获知通信内容；
2. 黑客可以修改通信内容；
3. 黑客可以冒充他人身份参与通信。

为此，HTTPS 具有以下特点：

1. 所有信息都是加密传播，第三方无法窃听；
2. 具有校验机制，一旦被篡改，通信双方会立刻发现；
3. 配备身份证书，防止身份被冒充。

## SSL/TLS 连接建立的过程

SSL/TLS 通讯同样需要先要进行“握手”，即客户端向服务器端索要并验证公钥，然后通过非对称加密双方协商生成“对话密钥“。“握手”阶段涉及四次通信，需要注意的是，”握手”阶段的所有通信都是明文的。

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/TCP%26IP/clipboard_20230323_031114.png)

### <strong>第一步：客户端发出请求</strong>

首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做 ClientHello 请求。

在这一步，客户端主要向服务器提供以下信息。

1. 支持的协议版本，比如 TLS 1.0 版。
2. 一个客户端生成的随机数，稍后用于生成“对话密钥”。
3. 支持的加密方法，比如 RSA 公钥加密。
4. 支持的压缩方法。

### <strong>第二步：服务器回应</strong>

服务器收到客户端请求后，向客户端发出回应，这叫做 ServerHello。服务器的回应包含以下内容。

1. 确认使用的加密通信协议版本，比如 TLS 1.0 版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
2. 一个服务器生成的随机数，稍后用于生成“对话密钥”。
3. 确认使用的加密方法，比如 RSA 公钥加密。
4. 服务器证书。

除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供“客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供 USB 密钥，里面就包含了一张客户端证书。

### <strong>第三步：客户端回应</strong>

客户端收到服务器回应以后，首先验证服务器证书。如果证书不合法<strong>，</strong>就会向访问者显示一个警告，由其选择是否还要继续通信。

1）验证域名、有效期等信息是否正确：证书上都有包含这些信息，比较容易完成验证；

2）判断证书来源是否合法：每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发证书完成来源验证；

3）判断证书是否被篡改：需要与 CA 服务器进行校验；

4）判断证书是否已吊销：通过 CRL（Certificate Revocation List 证书注销列表）和 OCSP（Online Certificate Status Protocol 在线证书状态协议）实现，其中 OCSP 可用于第 3 步中以减少与 CA 服务器的交互，提高验证效率。

如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。

1. 一个随机数。该随机数用服务器公钥加密，防止被窃听。
2. 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
3. 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的<strong>所有内容的 hash 值</strong>，用来供服务器校验。

上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称“pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，用这三个随机数各自生成本次会话所用的“会话密钥”。

### <strong>第四步：服务器的最后回应</strong>

服务器收到客户端的第三个随机数 pre-master key 之后，计算生成本次会话所用的“会话密钥”。然后，向客户端最后发送下面信息。

1. 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
2. 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的 hash 值，用来供客户端校验。

至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用“会话密钥”加密内容。

# 面试题

## 为什么需要第三次握手?

TCP 连接是可靠的双工通信，在连接建立阶段必须确认双向通信都是 OK 的。理论上来讲这需要至少四次交互：

1. Client 发送 SYN；
2. Server 响应 ACK；
3. Server 发送 SYN；
4. Client 响应 ACK (如果没有这一步，Server 无法知道 Client 能否收到自己的消息）。

1、2 两步让 Client 知道自己和 Server 之间的双向通信是 OK 的；3、4 两步让 Server 知道自己和 Client 之间的双向通信是 OK 的。实际应用中，2、3 两步合并了，所以最终就只有三次握手。

三次握手还可以解决<strong>网络中延迟的重复分组问题</strong>。假设 TC 连接建立过程只有两次握手：

1. Client 发送 SYN
2. Server 响应 ACK

如果没有第三次握手，出现下面的情况，服务端可能会出现如下问题：

1. Client 发送 SYN；
2. Client 端超时未收到 Server 的 ACK，重发 SYN；
3. Server 端收到 Client 重发的 SYN，响应 ACK；
4. Client 收到 ACK 后，和 Server 正常数据交互，然后关闭连接；
5. Client 第一次发送的 SYN 并未丢失，而是由于网络延迟，现在才到达 Server 端；
6. Server 发送 ACK（Server 认为 TCP 连接已建立）；
7. Client 收到 Server 的 ACK，由于 Client 认为自己并未请求连接，所以会忽略该 ACK（ACK 报文不需要回复）；
8. 这时 Server 认为连接已经建立，一直等待客户端数据，而客户端却根本不知道有这么一条连接。

## 收到服务器端的连接释放报文段之后，客户端还要继续等待 2MSL 之后才关闭 TCP 连接呢？

- <strong>为了保证主动关闭方发送的最后一个 ACK 报文能够到达被动关闭方</strong>。因为这个 ACK 有可能无法到达对端，这样对端会重发 FIN 报文，这时候主动关闭方需要重发 ACK。
- <strong>保证本连接的所有报文在网络上消失</strong>。如果没有这个机制，可能会对新连接产生干扰。举例如下：

  1. A 和 B 正常建立 TCP 连接，数据传输，然后断开连接。但是由于网络传输原因，A 发给 B 的 seq 为 100 的报文滞留在了网络上。
  2. A 和 B 再次建立连接，所用 IP 和端口与上一步中相同，二者数据传输过程中，B 正好请求 A 发送 seq 为 100 的数据，这时上一步中滞留的报文到达 B，TCP 认为该报文合法，就接收了这个报文。

## 为什么 TCP 释放连接需要四次？

TCP 连接是全双工的，因此每个方向都必须单独进行关闭：当一方完成它的数据发送任务后就发送一个 FIN 来终止这个方向的连接，对端收到后回复一个 ACK 报文，这样双向就需要四次交互。

Client 主动关闭的情况下，Server 收到 Client 的 FIN 报文时，仅仅表示 Client 没有数据发送给 Server 了；但 Server 可能还有数据要发送给 Client，所以 Server 可能并不会立即关闭 SOCKET，而是先回复一个 ACK 报文，告诉 Client“你发的 FIN 报文我收到了”。只有等到 Server 所有的报文都发送完了，才发送 FIN 报文。也就是说，被动关闭方的 ACK 和 FIN 报文多数情况下都是分开发送的，所以需要四次交互。
