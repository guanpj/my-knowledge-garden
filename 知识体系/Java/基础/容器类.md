---
title: 容器类
comments: true
date created: 2023-03-22
date modified: 2023-03-22
id: home
layout: page
tags:
  - Collection
  - Iterable
  - Java 容器类
  - Java
---
全家福：
![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095328.png)
# Iterable 接口

可迭代的意思，实现此接口允许对象成为“for-each”循环语句的目标，提供 iterator 方法用于遍历元素。

```java
public interface Iterable<T> {
    Iterator<T> iterator();

    default void forEach(Consumer<? super T> action) {
        Objects.requireNonNull(action);
        for (T t : this) {
            action.accept(t);
        }
    }

    default Spliterator<T> spliterator() {
        return Spliterators.spliteratorUnknownSize(iterator(), 0);
    }
}
```

Iterator 意思为迭代器，它的定义如下：

```java
public interface Iterator<E> {
    boolean hasNext();

    E next();

    default void remove() {
        throw new UnsupportedOperationException("remove");
    }

    default void forEachRemaining(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        while (hasNext())
            action.accept(next());
    }
}
```

迭代其实我们可以简单地理解为遍历，是一个标准化遍历各类容器里面的所有对象的接口。它是一个经典的设计模式——迭代器模式（Iterator）。 迭代器模式提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示。

<strong>注意：</strong>当使用 Iterator 对集合元素进行迭代时，Iterator 并不是把集合元素本身传给了迭代变量，而是把集合元素的值传给了迭代变量（就如同参数传递是值传递，基本数据类型传递的是值，引用类型传递的仅仅是对象的引用变量），所以修改迭代变量的值对集合元素本身没有任何影响。

# Collection 接口

Collection 接口为集合层次的根接口，Collection 框架概览如图：
![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095429.png)
Collection 接口中的关键方法定义如下：

```java
public interface Collection<E> extends Iterable<E> {
    // 集合大小
    int size();
    // 是否为空
    boolean isEmpty();
    // 是否包含此元素 o
    boolean contains(Object o);
    // 迭代器
    Iterator<E> iterator();
    // 转换成数组
    Object[] toArray();
    // 转换成指定类型数组
    <T> T[] toArray(T[] a);
    // 添加元素 e
    boolean add(E e);
    // 移除元素 o
    boolean remove(Object o);
    // 是否包含另一集合 c
    boolean containsAll(Collection<?> c);
    // 移除所有集合 c 中的元素
    boolean removeAll(Collection<?> c);
    /**
     * 移除符合条件的元素
     * @since 1.8
     */
    default boolean removeIf(Predicate<? super E> filter) {
        Objects.requireNonNull(filter);
        boolean removed = false;
        final Iterator<E> each = iterator();
        while (each.hasNext()) {
            if (filter.test(each.next())) {
                each.remove();
                removed = true;
            }
        }
        return removed;
    }
    // 判断集合中是否有不存在集合 c 中的元素
    boolean retainAll(Collection<?> c);
    // 清空所有元素
    void clear();
    /**
     * @since 1.8
     */
    @Override
    default Spliterator<E> spliterator() {
        return Spliterators.spliterator(this, 0);
    }
    /**
     * @since 1.8
     */
    default Stream<E> stream() {
        return StreamSupport.stream(spliterator(), false);
    }
    /**
     * @since 1.8
     */
    default Stream<E> parallelStream() {
        return StreamSupport.stream(spliterator(), true);
    }
}
可以看出 Collection 有添加、删除和清除元素等方法。
```

Collection 接口下属有三个关键子借口，分别为 Set、Queue 和 List。

## Set 接口

Set 集合与 Collection 集合基本相同，没有提供任何额外的方法。实际上 Set 就是 Collection，只是行为略有不同（Set 不允许包含重复元素）。

Set 集合不允许包含相同的元素，如果试图把两个相同的元素加入同一个 Set 集合中，则 add() 方法会返回 false，且新元素不会被加入。

```java
public interface Set<E> extends Collection<E> {
    int size();

    boolean isEmpty();

    boolean contains(Object o);

    Iterator<E> iterator();
    
    Object[] toArray();

    <T> T[] toArray(T[] a);

    boolean add(E e);

    boolean remove(Object o);

    boolean containsAll(Collection<?> c);

    boolean addAll(Collection<? extends E> c);
    
    boolean removeAll(Collection<?> c);

    void clear();
    /**
     * @since 1.8
     */
    @Override
    default Spliterator<E> spliterator() {
        return Spliterators.spliterator(this, Spliterator.DISTINCT);
    }
}
```

### HashSet 类

HashSet 是 Set 接口的典型实现，实现了 Set 接口中的所有方法，并没有添加额外的方法，大多数时候使用 Set 集合时就是使用这个实现类。使用的底层结构是 HashMap，按 Hash 算法来存储集合中的元素，因此具有很好的存取和查找性能。它的实现如下：

```java
public class HashSet<E> extends AbstractSet<E> implements Set<E> {
    static final long serialVersionUID = -5024744406713321676L;

    private transient HashMap<E,Object> map;

    private static final Object PRESENT = new Object();

    public HashSet() {
        map = new HashMap<>();
    }

    public HashSet(Collection<? extends E> c) {
        map = new HashMap<>(Math.max((int) (c.size()/.75f) + 1, 16));
        addAll(c);
    }

    public HashSet(int initialCapacity, float loadFactor) {
        map = new HashMap<>(initialCapacity, loadFactor);
    }

    public HashSet(int initialCapacity) {
        map = new HashMap<>(initialCapacity);
    }

    // dummy 并没有作用，只是用来区分重载构造方法
    HashSet(int initialCapacity, float loadFactor, boolean dummy) {
        map = new LinkedHashMap<>(initialCapacity, loadFactor);
    }

    public Iterator<E> iterator() {
        return map.keySet().iterator();
    }

    public int size() {
        return map.size();
    }

    public boolean isEmpty() {
        return map.isEmpty();
    }

    public boolean contains(Object o) {
        return map.containsKey(o);
    }

    public boolean add(E e) {
        return map.put(e, PRESENT)==null;
    }

    public boolean remove(Object o) {
        return map.remove(o)==PRESENT;
    }

    public void clear() {
        map.clear();
    }
}
```

可以看出 HashSet 内部其实是一个 HashMap。它的 add(E e) 方法会调用 HashMap 的 put 方法，插入的值会作为 put 的 key 并且把 PRESENT 作为 put 方法的 value 值进行插入，put 方法新增一个原来不存在的值会返回 null，如果原来存在的话会返回原来存在的值，所以是 HashMap 保证了元素不重复。

#### 特点

- 不能保证元素的排列顺序，顺序可能与添加顺序不同，顺序也有可能发生变化。
- HashSet 不是线程安全的，如果多个线程同时访问一个 HashSet，则必须通过代码来保证其同步。
- 集合元素值可以是 null。

#### 添加元素规则

两个对象比较，具体分为如下四个情况：

1. equals() 方法返回 false，hashCode() 方法返回不相等，HashSet 将会把它们存储在不同的位置。
2. equals() 方法返回 true，hashCode() 方法返回不相等，HashSet 将会把它们存储在不同的位置。
3. equals() 方法返回 true，hashCode() 方法比较相等，HashSet 将会把它们存储在相同的位置，在这个位置以链表式结构来保存多个对象。这是因为当向 HashSet 集合中存入一个元素时，HashSet 会调用对象的 hashCode() 方法来得到对象的 hashCode 值，然后根据该 hashCode 值来决定该对象存储在 HashSet 中存储位置。
4. equals() 方法返回 true，hashCode() 方法返回 true，HashSet 将不予添加。

如果 HashSet 中两个以上的元素具有相同的 hashCode 值，将会导致性能下降。所以如果重写类的 equals() 方法和 hashCode() 方法时，应尽量保证两个对象通过 hashCode() 方法返回值相等时，通过 equals() 方法比较返回 true。

### LinkedHashSet 类

LinkedHashSet 是 HashSet 的子类，也是根据元素的 hashCode 值来决定元素的存储位置，同时使用链表维护元素的次序，使得元素是以插入的顺序来保存的。当遍历 LinkedHashSet 集合里的元素时，LinkedHashSet 将会按元素的添加顺序来访问集合里的元素。但是由于要维护元素的插入顺序，在性能上略低与 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。

它的实现如下：

```java
public class LinkedHashSet<E> extends HashSet<E> implements Set<E> {

    private static final long serialVersionUID = -2851667679971038690L;

    public LinkedHashSet(int initialCapacity, float loadFactor) {
        super(initialCapacity, loadFactor, true);
    }

    public LinkedHashSet(int initialCapacity) {
        super(initialCapacity, .75f, true);
    }

    public LinkedHashSet() {
        super(16, .75f, true);
    }

    public LinkedHashSet(Collection<? extends E> c) {
        super(Math.max(2*c.size(), 11), .75f, true);
        addAll(c);
    }

    @Override
    public Spliterator<E> spliterator() {
        return Spliterators.spliterator(this, Spliterator.DISTINCT | 
Spliterator.ORDERED);
    }
}

```

可以看到，它的构造方法都是通过调用父类 HashSet 的三个参数的构造方法。

HashSet 的构造分方法如下：

```java
HashSet(int initialCapacity, float loadFactor, boolean dummy) {
    map = new LinkedHashMap<>(initialCapacity, loadFactor)
}
```

LinkedHashMap 的实现见后文。

### TreeSet 类

TreeSet 是 SortedSet 接口的实现类，正如 SortedSet 名字所暗示的，TreeSet 可以确保集合元素处于排序状态。此外，TreeSet 还提供了几个额外的方法。

#### 主要方法

comparator()：返回对此 set 中的元素进行排序的比较器；如果此 set 使用其元素的自然顺序，则返回 null。

first()：返回此 set 中当前第一个（最低）元素。

last()：返回此 set 中当前最后一个（最高）元素。

lower(E e)：返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null。

higher(E e)：返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null。

floor(E e)：返回此 set 中小于等于给定元素的最小值；如果不存在这样的元素，则返回 null。

ceiling(E e)：返回此 set 中大于给定元素的最大值；如果不存在这样的元素，则返回 null。

subSet(E fromElement, E toElement)：返回此 set 的部分视图，其元素从 fromElement（包括）到 toElement（不包括）。

headSet(E toElement)：返回此 set 的部分视图，其元素小于 toElement。

tailSet(E fromElement)：返回此 set 的部分视图，其元素大于等于 fromElement。

#### 排序方式

TreeSet 中所谓的有序，不同于之前所讲的插入顺序，而是通过集合中元素属性进行排序方式来实现的。TreeSet 支持两种排序方法：自然排序和定制排序。在默认情况下，TreeSet 采用自然排序。

##### <strong>自然排序</strong>

TreeSet 会调用集合中元素所属类的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序排列，即把通过 compareTo(Object obj) 方法比较后比较大的的往后排。这种方式就是自然排序。

除了已经实现 Comparable 接口类（String 和 Integer 等）之外，如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable 接口，否则就会出现异常。

<strong>注意：</strong>TreeSet 中只能添加同一种类型的对象，否则无法比较，会出现异常。

当一个对象调用该方法与另一个对象比较时，例如 obj1.compareTo(obj2)，如果该方法返回 0，则表明两个对象相等；如果该方法返回一个正整数，则表明 obj1 大于 obj2；如果该方法返回一个负整数，则表明 obj1 小于 obj2。

##### <strong>定制排序</strong>

定制排序是通过 Comparator 接口实现的。该接口包含一个 int compare(T o1,T o2) 方法，该方法用于比较 o1, o2 的大小：如果该方法返回正整数，则表明 o1 大于 o2；如果该方法返回 0，则表明 o1 等于 o2；如果该方法返回负整数，则表明 o1 小于 o2。

如果要实现定制排序，则需要在创建 TreeSet 时，调用一个带参构造器，传入 Comparator 对 象。并有该 Comparator 对象负责集合元素的排序逻辑，此时集合元素可以不必实现 Comparable 接口。

#### 判断元素相等

对于 TreeSet 集合而言，判断两个对象是否相等的唯一标准是：两个对象通过 compareTo(Object obj) 方法比较是否返回 0——如果通过 compareTo(Object obj) 方法比较返回 0，TreeSet 则会认为它们相等，不予添加入集合内；否则就认为它们不相等，添加到集合内。

<strong>TreeSet 是根据红黑树结构找到集合元素的存储位置。</strong>

注意：

1. 无论使用自然排序还是定制排序，都可以通过自定义比较逻辑实现各种各样的排序方式。
2. 如果向 TreeSet 中添加了一个可变对象后，并且后面程序修改了该可变对象的实例变量，这将导致它与其他对象的大小顺序发生了改变，但 TreeSet 不会再次调整它们。
3. TreeSet 也是非线程安全的。

### HashSet 和 TreeSet 对比

<strong>性能：HashSet > LinkedHashSet >TreeSet</strong>

- HashSet 以 hash 算法进行位置存储，特别适合用于添加、查询操作。
- LinkedHashSet 由于要维护链表，性能比 HashSet 差点，但是有了链表，LinkedHashSet 更适合于插入、删除以及遍历操作。
- TreeSet 需要额外的红黑树算法来维护集合的次序，性能最次。

但是具体使用要考虑具体的使用场景。

当需要一个特定排序的集合时，使用 TreeSet 集合。

当经常使用添加、查询操作时，使用 HashSet。

当经常插入排序或使用删除、插入及遍历操作时，使用 LinkedHashSet。

## Queue 接口

Queue 用户模拟队列这种数据结构，队列通常是指“先进先出”(FIFO，first-in-first-out)的容器。队列的头部是在队列中存放时间最长的元素，队列的尾部是保存在队列中存放时间最短的元素。新元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素。通常队列不允许随机访问其中的元素。

```java
public interface Queue<E> extends Collection<E> {
    // 插入元素，容量已满时抛出 IllegalStateException 异常
    boolean add(E e);
    // 插入元素，容量已满时返回 false
    boolean offer(E e);
    // 移除队列头部元素并返回，当集合为空时抛出异常
    E remove();
    // 移除队列头部元素并返回，当集合为空时返回 null
    E poll();
    // 获取队列中第一个元素，当集合为空时抛出异常
    E element();
    // 获取队列中第一个元素，当集合为空时返回 null
    E peek();
}
```

### Deque 接口

Deque 接口是 Queue 接口的子接口，它代表一个双端队列。

就是说对于这个队列容器，既可以从头部插入也可以从尾部插入，既可以从头部获取，也可以从尾部获取，其机制如下图所示：
![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095517.png)
LinkedList 也实现了 Deque 接口，所以也可以被当作双端队列使用。

#### 主要方法

void addFirst(E e):将指定元素插入此列表的开头。

void addLast(E e): 将指定元素添加到此列表的结尾。

E getFirst(E e): 返回此列表的第一个元素。

E getLast(E e): 返回此列表的最后一个元素。

boolean offerFirst(E e): 在此列表的开头插入指定的元素。

boolean offerLast(E e): 在此列表末尾插入指定的元素。

E peekFirst(E e): 获取但不移除此列表的第一个元素；如果此列表为空，则返回 null。

E peekLast(E e): 获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null。

E pollFirst(E e): 获取并移除此列表的第一个元素；如果此列表为空，则返回 null。

E pollLast(E e): 获取并移除此列表的最后一个元素；如果此列表为空，则返回 null。

E removeFirst(E e): 移除并返回此列表的第一个元素。

boolean removeFirstOccurrence(Objcet o): 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。

E removeLast(E e): 移除并返回此列表的最后一个元素。

boolean removeLastOccurrence(Objcet o): 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。

从上面方法中可以看出，Deque 不仅可以当成双端队列使用，而且可以被当成栈来使用，因为该类里还包含了 pop(出栈)、push(入栈)两个方法。

#### 与 Queue、Stack 的关系

当 Deque 当做 Queue 队列使用时（FIFO），添加元素是添加到队尾，删除时删除的是头部元素。从 Queue 接口继承的方法对应 Deque 的方法如下：
![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095628.png)
Deque 也能当 Stack 栈用（LIFO）。这时入栈、出栈元素都是在双端队列的头部进行。Deque  中和 Stack 对应的方法如下：
![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095654.png)
<strong>注意：</strong>Stack 过于古老，并且实现地非常不好，因此现在基本已经不用了，可以直接用 Deque 来代替 Stack 进行栈操作。

#### ArrayDeque 类

顾名思义，就是用数组实现的 Deque。既然底层是数组那肯定也可以指定其 capacity，也可以不指定，<strong>默认长度是 16</strong>，然后根据添加的元素的个数，动态扩展。ArrayDeque 由于是两端队列，所以其顺序是按照元素插入数组中对应位置产生的（下面会具体说明）。

由于本身数据结构的限制，ArrayDeque 没有像 ArrayList 中的 trimToSize 方法可以为自己瘦身。ArrayDeque 的使用方法就是上面的 Deque 的使用方法，基本没有对 Deque 拓展什么方法。

##### <strong>实现原理</strong>

ArrayDeque 为了满足可以同时在数组两端插入或删除元素的需求，其内部的动态数组还必须是循环的，即循环数组（circular array），也就是说数组的任何一点都可能被看作起点或者终点。

ArrayDeque 维护了两个变量，表示 ArrayDeque 的头和尾：

```java
//具体存放元素的数组，数组大小一定是2的幂次方
transient Object[] elements; // non-private to 
//队列头索引
transient int head;
//队列尾索引
transient int tail;
//默认的最小初始化容量，即传入的容量小于8容量为8，而默认容量是16
private static final int MIN_INITIAL_CAPACITY = 8;
```

当向头部插入元素时，head 下标减一然后插入元素。而 tail 表示的索引为当前末尾元素表示的索引值加一。若当向尾部插入元素时，直接向 tail 表示的位置插入，然后 tail 再减一。
![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095736.png)

最初头部和尾部索引都是 0，addLast 方向往右，addFirst 方向往左，所以数组中间可能是空的，当头指针和尾指针相遇的时候对数组进行扩容，并对元素位置进行调整。

注意：ArrayDeque 不是线程安全的。 当作为栈使用时，性能比 Stack 好；当作为队列使用时，性能比 LinkedList 好。

### PriorityQueue 类

PriorityQueue 是 Java 中唯一一个 Queue 接口的直接实现。PriorityQueue 保存队列元素的顺序不是按加入队列的顺序，而是按特定规则进行排序的。因此当调用 peek() 或 poll() 方法取出队列中头部的元素时，并不是取出最先进入队列的元素，而是取出队列中按规则排序最小的元素。

#### 方法概览

PriorityQueue 实现了 Queue 接口，下面列举出 PriorityQueue 的方法。
![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095901.png)

#### 排序方式

与 TreeSet 相同，PriorityQueue 中的元素可以默认自然排序（也就是数字默认是小的在队列头，字符串则按字典序排列）或者通过提供的 Comparator（比较器）在队列实例化时指定的排序方式。

<strong>注意：</strong>

1. 队列的头是按指定排序方式的最小元素。如果多个元素都是最小值，则头是其中一个元素——选择方法是任意的。
2. 当 PriorityQueue 中没有指定 Comparator 时，加入 PriorityQueue 的元素必须实现 Comparable 接口（即元素是可比较的），否则会导致 ClassCastException。

#### 实现原理

PriorityQueue 本质也是一个动态数组，在这一方面与 ArrayList 是一致的。它的成员变量和构造方法如下：

```java
public class PriorityQueue<E> extends AbstractQueue<E>
    implements java.io.Serializable {
    private static final int DEFAULT_INITIAL_CAPACITY = 11;

    transient Object[] queue; // non-private to simplify nested class access


    private int size = 0;

    private final Comparator<? super E> comparator;

    transient int modCount = 0; // non-private to simplify nested class access

    public PriorityQueue() {
      this(DEFAULT_INITIAL_CAPACITY, null);
    }

    public PriorityQueue(int initialCapacity) {
      this(initialCapacity, null);
    }

    public PriorityQueue(int initialCapacity,
                         Comparator<? super E> comparator) {
      // Note: This restriction of at least one is not actually 
      needed,but continues for 1.5 compatibility
      if (initialCapacity < 1)
        throw new IllegalArgumentException();
      this.queue = new Object[initialCapacity];
      this.comparator = comparator;
    }
    ...
}
```

PriorityQueue 可由以下三种构造方法创建：

- 调用默认的构造方法时，使用默认的初始容量（DEFAULT_INITIAL_CAPACITY=11），并根据其自然顺序来排序其元素（使用加入其中的集合元素实现的 Comparable）。
- 使用指定的初始容量，并根据其自然顺序来排序其元素（使用加入其中的集合元素实现的 Comparable）。
- 使用指定的初始容量，并根据指定的比较器 comparator 来排序其元素。

从第三个构造方法可以看出，内部维护了一个动态数组。当添加元素到集合时，会先检查数组是否还有余量，有余量则把新元素加入集合，没余量则调用  grow() 方法增加容量，然后调用 siftUp 将新加入的元素排序插入对应位置。

```java
public boolean offer(E e) {
    if (e == null)
        throw new NullPointerException();
    modCount++;
    int i = size;
    if (i >= queue.length)
        grow(i + 1);
    size = i + 1;
    if (i == 0)
        queue[0] = e;
    else
        siftUp(i, e);
    return true;
}
```

除此之外，还要注意：

1. PriorityQueue 不是线程安全的。如果多个线程中的任意线程从结构上修改了列表， 则这些线程不应同时访问 PriorityQueue 实例，这时请使用线程安全的 PriorityBlockingQueue 类。
2. 不允许插入 null 元素。
3. PriorityQueue 实现插入方法（offer、poll、remove() 和 add 方法） 的时间复杂度是 O(log(n)) ；实现 remove(Object) 和 contains(Object) 方法的时间复杂度是 O(n) ；实现检索方法（peek、element 和 size）的时间复杂度是 O(1)。所以在遍历时，若不需要删除元素，则以 peek 的方式遍历每个元素。
4. 方法 iterator() 中提供的迭代器并不保证以有序的方式遍历优 PriorityQueue 中的元素。

## List 接口

List 集合代表一个<strong>元素有序、可重复</strong>的集合，集合中每个元素都有其对应的顺序索引。List 集合允许使用重复元素，可以通过索引来访问指定位置的集合元素 。List 集合默认按元素的添加顺序设置元素的索引，例如第一个添加的元素索引为 0，第二个添加的元素索引为 1......

List 作为 Collection 接口的子接口，可以使用 Collection 接口里的全部方法。而且由于 List 是有序集合，因此 List 集合里增加了一些根据索引来操作集合元素的方法。

```java
public interface List<E> extends Collection<E> {
    int size();

    boolean isEmpty();

    boolean contains(Object o);

    Iterator<E> iterator();

    Object[] toArray();

    <T> T[] toArray(T[] a);

    boolean add(E e);

    boolean remove(Object o);

    boolean containsAll(Collection<?> c);
    
    boolean addAll(Collection<? extends E> c);
    
    boolean addAll(int index, Collection<? extends E> c);
    
    boolean removeAll(Collection<?> c);
    
    boolean retainAll(Collection<?> c);
    /**
     * 根据 operator 指定的计算规则重新设置 List 集合的所有元素
     * @since 1.8
     */
    default void replaceAll(UnaryOperator<E> operator) {
        Objects.requireNonNull(operator);
        final ListIterator<E> li = this.listIterator();
        while (li.hasNext()) {
            li.set(operator.apply(li.next()));
        }
    }
    /**
     * 根据Comparator参数对List集合的元素排序
     * @since 1.8
     */
    default void sort(Comparator<? super E> c) {
        Object[] a = this.toArray();
        Arrays.sort(a, (Comparator) c);
        ListIterator<E> i = this.listIterator();
        for (Object e : a) {
            i.next();
            i.set((E) e);
        }
    }

    void clear();
    // 根据下标获取元素
    E get(int index);
    // 替换指定下标位置的元素
    E set(int index, E element);
    // 在指定下标位置插入元素
    void add(int index, E element);
    // 根据下标删除元素
    E remove(int index);
    // 获取元素下标，不存在则返回 -1
    int indexOf(Object o);
    // 获取与元素最后一个下标，，不存在则返回 -1
    int lastIndexOf(Object o);

    ListIterator<E> listIterator();
    
    ListIterator<E> listIterator(int index);
    
    List<E> subList(int fromIndex, int toIndex);
    /**
     * @since 1.8
     */
    @Override
    default Spliterator<E> spliterator() {
        return Spliterators.spliterator(this, Spliterator.ORDERED);
    }
}
```

可以看出，经过扩展之后，List 相比于 Collection 多了“顺序”的概念，并且支持根据下表对集合进行操作。

isEmpty()、contains() 等方法重新声明是为了为了方便查看文档。比如在 java doc 文档里，在 List 接口里也能看到 Collecion 声明的相关接口。

此外，Java 8 为 List 接口添加了如下两个默认方法：

- <strong>void replaceAll(UnaryOperator operator)：</strong>根据 operator 指定的计算规则重新设置 List 集合的所有元素。
- <strong>void sort(Comparator c)：</strong>根据 Comparator 参数对 List 集合的元素排序。

ListIterator 接口在 Iterator 接口基础上增加了如下方法：

- <strong>boolean hasPrevious()：</strong> 如果以逆向遍历列表。如果迭代器有上一个元素，则返回 true。
- <strong>Object previous()：</strong>返回迭代器的前一个元素。
- <strong>void add(Object o)：</strong>将指定的元素插入列表（可选操作）。

与 Iterator 相比，ListIterator 增加了前向迭代的功能，还可以通过 add() 方法向 List 集合中添加元素。

### ArrayList 类

ArrayList 作为 List 类的典型实现，完全支持之前介绍的 List 接口的全部功能。它的成员变量和构造方法声明如下：

```java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess {
    /**
     * 默认初始容量大小
     */
    private static final int DEFAULT_CAPACITY = 10;

    private static final Object[] EMPTY_ELEMENTDATA = {};

    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

    transient Object[] elementData;
    
    private int size;
    
    /**
     * 默认构造函数，使用初始容量10构造一个空列表(无参数构造)
     */
    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }
    
    /**
     * 带初始容量参数的构造函数。（用户自己指定容量）
     */
    public ArrayList(int initialCapacity) {
        if (initialCapacity > 0) {//初始容量大于0
            //创建 initialCapacity 大小的数组
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {//初始容量等于0
            // 创建空数组
            this.elementData = EMPTY_ELEMENTDATA;
        } else {// 初始容量小于 0，抛出异常
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        }
    }

   /**
    * 构造包含指定 collection 元素的列表，这些元素利用该集合的迭代器按顺序返回
    * 如果指定的集合为 null，throws NullPointerException。
    */
     public ArrayList(Collection<? extends E> c) {
        elementData = c.toArray();
        if ((size = elementData.length) != 0) {
            // c.toArray might (incorrectly) not return Object[] (see 6260652)
            if (elementData.getClass() != Object[].class)
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        } else {
            // replace with empty array.
            this.elementData = EMPTY_ELEMENTDATA;
        }
    }
    ...
}
```

ArrayList 是基于数组实现的 List 类，所以 ArrayList 类封装了一个动态的、允许再分配的 Object[] 数组。ArrayList 对象使用 initalCapacity 参数来设置该数组的长度，当向 ArrayList 中添加元素超过了该数组的长度时，它们的 initalCapacity 会自动增加。下面我们通过阅读 JDK 8 ArrayList 源码来了解这些内容。

#### 扩容机制

以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。 

JDK 7 new 无参构造的 ArrayList 对象时，直接创建了长度是 10 的 Object[] 数组 elementData 。并且 JDK 7 中的 ArrayList 的对象的创建类似于单例的饿汉式，而 JDK 8 中的 ArrayList 的对象的创建类似于单例的懒汉式。

添加元素时，首先调用 add 方法：

```java
/**
 * 将指定的元素追加到此列表的末尾。
 */
public boolean add(E e) {
    //添加元素之前，先调用ensureCapacityInternal方法
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    //这里看到ArrayList添加元素的实质就相当于为数组赋值
    elementData[size++] = e;
    return true;
}
```

先调用了一个 ensureCapacityInternal() 方法，该方法用来确保数组中是否还有足够容量。

<strong>注意 ：JDK 11 移除了 ensureCapacityInternal() 和 ensureExplicitCapacity() 方法 </strong>

经过一系列方法，最后有个判断：如果剩余容量足够存放这个数据，则进行下一步，如果不够，则需要执行一个重要的方法：

```java
/**
 * 要分配的最大数组大小
 */
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
/**
 * ArrayList 扩容的核心方法。
 */
private void grow(int minCapacity) {
   // oldCapacity 为旧容量，newCapacity 为新容量
   int oldCapacity = elementData.length;
   //将 oldCapacity 右移一位，其效果相当于 oldCapacity / 2，
   int newCapacity = oldCapacity + (oldCapacity >> 1);
   //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，
   if (newCapacity - minCapacity < 0)
      newCapacity = minCapacity;
   // 如果新容量大于 MAX_ARRAY_SIZE，进入(执行) hugeCapacity() 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，
   //如果 minCapacity大 于最大容量，则新容量则为 Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即 Integer.MAX_VALUE - 8。
   if (newCapacity - MAX_ARRAY_SIZE > 0)
      newCapacity = hugeCapacity(minCapacity);
   // minCapacity is usually close to size, so this is a win:
   elementData = Arrays.copyOf(elementData, newCapacity);
}
```

`int newCapacity = oldCapacity + (oldCapacity >> 1)`，所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）。

由此可见，ArrayList 是一个能够进行动态扩展的数组。

#### System.arraycopy() 和 Arrays.copyOf() 方法

Arrays.copyOf() 内部调用了 System.arraycopy() 方法，arraycopy() 方法由 native 层实现：

```java
public static int[] copyOf(int[] original, int newLength) {
   // 申请一个新的数组
   int[] copy = new int[newLength];
   // 调用System.arraycopy，将源数组中的数据进行拷贝，并返回新的数组
   System.arraycopy(original, 0, copy, 0,
           Math.min(original.length, newLength));
   return copy;
}

/**
 * @param src 源数组
 * @param srcPos 源数组中的起始位置
 * @param dest 目标数组
 * @param destPos 目标数组中的起始位置
 * @param length 要复制的数组元素的数量
 */
public static native void arraycopy(Object src,  int  srcPos,
                                    Object dest, int destPos,
                                    int length);
```

ensureCapacity() 和 trimToSize() 方法

- <strong>void ensureCapacity(int minCapacity): </strong>如有必要，增加此 ArrayList 实例的容量，以确保它至少能够容纳最小容量参数所指定的元素数。<strong>在增加大量数据之前，调用此方法，可以减少扩容次数。</strong>
- <strong>void trimToSize(): </strong>将此 ArrayList 实例的容量调整为列表的当前大小。

#### transient 的作用

从构造方法中可以看到，实际存放集合元素的数组声明时时被 transient 所修饰的：

`transient Object[] elementData;`

当一个对象被序行化的时候，transient 修饰的变量的值是不包括在序行化的表示中的。但是 ArrayList 又是可序行化的类，elementData 是 ArrayList 具体存放元素的成员，用 transient 来修饰 elementData，岂不是反序列化后的 ArrayList 丢失了原先的元素？

来看下面两个方法：

```java
private void writeObject(java.io.ObjectOutputStream s)
    throws java.io.IOException{
    // Write out element count, and any hidden stuff
    int expectedModCount = modCount;
    s.defaultWriteObject();

    // Write out size as capacity for behavioural compatibility with clone()
    s.writeInt(size);

    // Write out all elements in the proper order.
    for (int i=0; i<size; i++) {
        s.writeObject(elementData[i]);
    }

    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
}

/**
 * Reconstitute the <tt>ArrayList</tt> instance from a stream (that is,
 * deserialize it).
 */
private void readObject(java.io.ObjectInputStream s)
    throws java.io.IOException, ClassNotFoundException {
    elementData = EMPTY_ELEMENTDATA;

    // Read in size, and any hidden stuff
    s.defaultReadObject();

    // Read in capacity
    s.readInt(); // ignored

    if (size > 0) {
        // be like clone(), allocate array based upon size not capacity
        int capacity = calculateCapacity(elementData, size);
        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);
        ensureCapacityInternal(size);

        Object[] a = elementData;
        // Read in all elements in the proper order.
        for (int i=0; i<size; i++) {
            a[i] = s.readObject();
        }
    }
}
由于 elementData 的扩容机制，数组中可能有空元素。因此，每次序列化的时候调用 writeObject() 方法，进而调用 defaultWriteObject() 方法忽略 elementData 先序列化 ArrayList 中的非 transient 元素，然后再通过遍历 elementData 只序列化那些有的元素。
```

这样一来，既<strong>加快了序列化的速度，又减小了序列化之后的文件大小 。</strong>

反序列化时调用 readObject，从 ObjectInputStream 获取 size 和 element，再恢复到 elementData。

//todo

#### 遍历方式

ArrayList 支持 3 种遍历方式

<strong>第一种，通过迭代器遍历：</strong>

```java
Integer value = null;
Iterator iter = list.iterator();
while (iter.hasNext()) {
    value = ter.next();
}
```

<strong>第二种，随机访问，通过索引值去遍历：</strong>

由于 ArrayList 实现了 RandomAccess 接口，它支持通过索引值去随机访问元素。

```java
Integer value = null;
for (int i = 0; i < list.size(); i++) {
    value = list.get(i);        
}
```

<strong>第三种，for 循环遍历：</strong>

```java
Integer value = null;
for (Integer item : list) {
    value = item;
}
```

<strong>遍历 ArrayList 时，使用随机访问(通过索引序号访问)效率最高，而使用迭代器的效率最低。</strong>

<strong>//todo</strong>

### Vector 类

Vector 和 ArrayList 的实现基本类似，以 remove 方法为例：

```java
public synchronized E remove(int index) {
    modCount++;
    if (index >= elementCount)
        throw new ArrayIndexOutOfBoundsException(index);
    E oldValue = elementData(index);

    int numMoved = elementCount - index - 1;
    if (numMoved > 0)
        //复制数组，假设数组移除了中间某元素，后边有效值前移1位
        System.arraycopy(elementData, index+1, elementData, index,
                         numMoved);
    elementData[--elementCount] = null; // Let gc do its work

    return oldValue;
}
```

它的关键方法都加上了 synchronized 关键字，所以它是<strong>线程安全</strong>的，并且也因此<strong>降低了性能</strong>。

除此之外，它的扩容机制也与 ArrayList 有所不同：

```java
private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    //扩容大小
    int newCapacity = oldCapacity + ((capacityIncrement > 0) ?
                                     capacityIncrement : oldCapacity);
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

当构造没有设置 capacityIncrement 时，一次扩容数组变成原来两倍，否则每次容量增加  capacityIncrement。

#### Stack 类

Stack 是 Vector 的子类，用于模拟“栈”这种数据结构，即“后进先出”(LIFO)的容器。它提供了如下方法：

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095956.png)

由于继承自 Vector，Stack 自然也继承了 Vecor 线程安全和性能较低的特点。因此 Stack 类基本处于废弃状态，实现栈结构可由 LinkedList 代替。

### LinkedList 类

LinkedList 类是 List 接口的实现类——这意味着它是一个 List 集合，可以根据索引来随机访问集合中的元素。

```java
public class LinkedList<E> extends AbstractSequentialList<E>
             implements List<E>, Deque<E> {
    transient int size = 0;

    transient Node<E> first;

    transient Node<E> last;

    public LinkedList() {
    }

    public LinkedList(Collection<? extends E> c) {
        this();
        addAll(c);
    }
    ...
}
```

可以看出，LinkedList 还实现了 Deque 接口，可以被当作成双端队列来使用，因此既可以被当成<strong>栈</strong>来使用，也可以当成<strong>队列</strong>来使用。

LinkedList 的实现机制与 ArrayList 完全不同。ArrayList 内部是以数组的形式来保存集合中的元素的，因此随机访问集合元素时有较好的性能；而 L inkedList 内部以链表的形式来保存集合中的元素，因此随机访问集合元素时性能较差，但在插入、删除元素时性能比较出色。

由于 LinkedList 双端队列的特性，所以新增了一些方法。

#### 方法概览

```java
void addFirst(E e):将指定元素插入此列表的开头。
void addLast(E e): 将指定元素添加到此列表的结尾。
E getFirst(E e): 返回此列表的第一个元素。
E getLast(E e): 返回此列表的最后一个元素。
boolean offerFirst(E e): 在此列表的开头插入指定的元素。
boolean offerLast(E e): 在此列表末尾插入指定的元素。
E peekFirst(E e): 获取但不移除此列表的第一个元素；如果此列表为空，则返回 null。
E peekLast(E e): 获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null。
E pollFirst(E e): 获取并移除此列表的第一个元素；如果此列表为空，则返回 null。
E pollLast(E e): 获取并移除此列表的最后一个元素；如果此列表为空，则返回 null。
E removeFirst(E e): 移除并返回此列表的第一个元素。
boolean removeFirstOccurrence(Objcet o): 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。
E removeLast(E e): 移除并返回此列表的最后一个元素。
boolean removeLastOccurrence(Objcet o): 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。
```

#### 实现原理

LinkedList 调用默认构造函数，创建一个链表。由于维护了一个表头，表尾的 Node 对象的变量。可以进行后续的添加元素到链表中的操作，以及其他删除，插入等操作。也因此实现了双向队列的功能，即可向表头加入元素，也可以向表尾加入元素。

Node 定义如下：

```java
private static class Node<E> {
    E item;//节点值
    Node<E> next;//后继节点
    Node<E> prev;//前驱节点
    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
```

新增操作 add(E e)，默认使用尾插法添加元素：

```java
public boolean add(E e) {
    linkLast(e);
    return true;
}

void linkLast(E e) {
    final Node<E> l = last;
    final Node<E> newNode = new Node<>(l, e, null);
    last = newNode;
    if (l == null)
        first = newNode;
    else
        l.next = newNode;
    size++;
    modCount++;
}
```

删除指定元素 remove(Object o): 

```java
public boolean remove(Object o) {
    //如果删除对象为null
    if (o == null) {
        //从头开始遍历
        for (Node<E> x = first; x != null; x = x.next) {
            //找到元素
            if (x.item == null) {
                //从链表中移除找到的元素
                unlink(x);
                return true;
            }
        }
    } else {
        //从头开始遍历
        for (Node<E> x = first; x != null; x = x.next) {
            //找到元素
            if (o.equals(x.item)) {
                //从链表中移除找到的元素
                unlink(x);
                return true;
            }
        }
    }
    return false;
}

E unlink(Node<E> x) {
    // assert x != null;
    final E element = x.item;
    final Node<E> next = x.next;//得到后继节点
    final Node<E> prev = x.prev;//得到前驱节点
    //删除前驱指针
    if (prev == null) {
        first = next;// 如果删除的节点是头节点,令头节点指向该节点的后继节点
    } else {
        prev.next = next;// 将前驱节点的后继节点指向后继节点
        x.prev = null;
    }
    //删除后继指针
    if (next == null) {
        last = prev;//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点
    } else {
        next.prev = prev;
        x.next = null;
    }
    x.item = null;
    size--;
    modCount++;
    return element;
}
```

获取制定下表元素 get(int index):

```java
public E get(int index) {
    checkElementIndex(index);//检查索引是否有效
    return node(index).item;
}

Node<E> node(int index) {
    // assert isElementIndex(index);
    if (index < (size >> 1)) {
        Node<E> x = first;
        for (int i = 0; i < index; i++)
            x = x.next;
        return x;
    } else {
        Node<E> x = last;
        for (int i = size - 1; i > index; i--)
            x = x.prev;
        return x;
    }
}
```

node 方法首先会比较“index”和“双向链表长度的 1/2”；若前者小，则从链表头开始往后查找，直到 index 位置；否则，从链表末尾开始先前查找，直到 index 位置。

由此可见，LinkedList 在插入、删除元素时性能比较出色，随机访问集合元素时性能较差。

#### 遍历方式

//todo

# Map 接口

Map 用于保存具有映射关系的数据。它是一种键值对的结构，即 Key-Value 结构，一个 Map 就是很多这样 K-V 键值对组成的，一个 K-V 结构我们将其称作 Entry，Key 和 Value 都可以是任何引用类型的数据。Map 的 Key 不允许重复，即同一个 Map 对象的任何两个 Key 通过 equals 方法比较总是返回 false。

Key 和 Value 之间存在单向一对一关系，即通过指定的 Key，总能找到唯一的、确定的 Value。从 Map 中取出数据时，只要给出指定的 Key，就可以取出对应的 Value。

Map 框架概览：
![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_100030.png)

Map 接口的定义如下：

```java
public interface Map<K,V> {
    int size();

    boolean isEmpty();
    
    boolean containsKey(Object key);
    
    boolean containsValue(Object value);
    
    V get(Object key);
    
    V put(K key, V value);
    
    V remove(Object key);

    void putAll(Map<? extends K, ? extends V> m);
    
    void clear();

    Set<K> keySet();
    
    Collection<V> values();
    
    Entry<K, V>> entrySet();
    
    interface Entry<K,V> {
        K getKey();

        V getValue();
        
        V setValue(V value);
        
        boolean equals(Object o);
        
        int hashCode();
        /**
         * @since 1.8
         */
        public static <K extends Comparable<? super K>, V> Comparator<Map.Entry<K,V>> comparingByKey() {
            return (Comparator<Map.Entry<K, V>> & Serializable)
                (c1, c2) -> c1.getKey().compareTo(c2.getKey());
        }
        /**
         * @since 1.8
         */
        public static <K, V extends Comparable<? super V>> Comparator<Map.Entry<K,V>> comparingByValue() {
            return (Comparator<Map.Entry<K, V>> & Serializable)
                (c1, c2) -> c1.getValue().compareTo(c2.getValue());
        }
        /**
         * @since 1.8
         */
        public static <K, V> Comparator<Map.Entry<K, V>> comparingByKey(Comparator<? super K> cmp) {
            Objects.requireNonNull(cmp);
            return (Comparator<Map.Entry<K, V>> & Serializable)
                (c1, c2) -> cmp.compare(c1.getKey(), c2.getKey());
        }
        /**
         * @since 1.8
         */
        public static <K, V> Comparator<Map.Entry<K, V>> comparingByValue(Comparator<? super V> cmp) {
            Objects.requireNonNull(cmp);
            return (Comparator<Map.Entry<K, V>> & Serializable)
                (c1, c2) -> cmp.compare(c1.getValue(), c2.getValue());
        }
    }

    boolean equals(Object o);

    int hashCode();
    // Defaultable methods
    /**
     * @since 1.8
     */
    default V getOrDefault(Object key, V defaultValue) {
        V v;
        return (((v = get(key)) != null) || containsKey(key))
            ? v
            : defaultValue;
    }
    /**
     * @since 1.8
     */
    default void forEach(BiConsumer<? super K, ? super V> action) {
        Objects.requireNonNull(action);
        for (Map.Entry<K, V> entry : entrySet()) {
            K k;
            V v;
            try {
                k = entry.getKey();
                v = entry.getValue();
            } catch(IllegalStateException ise) {
                // this usually means the entry is no longer in the map.
                throw new ConcurrentModificationException(ise);
            }
            action.accept(k, v);
        }
    }
    /**
     * @since 1.8
     */
    default void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {
        Objects.requireNonNull(function);
        for (Map.Entry<K, V> entry : entrySet()) {
            K k;
            V v;
            try {
                k = entry.getKey();
                v = entry.getValue();
            } catch(IllegalStateException ise) {
                // this usually means the entry is no longer in the map.
                throw new ConcurrentModificationException(ise);
            }
            // ise thrown from function is not a cme.
            v = function.apply(k, v);
            try {
                entry.setValue(v);
            } catch(IllegalStateException ise) {
                // this usually means the entry is no longer in the map.
                throw new ConcurrentModificationException(ise);
            }
        }
    }
    /**
     * @since 1.8
     */
    default V putIfAbsent(K key, V value) {
        V v = get(key);
        if (v == null) {
            v = put(key, value);
        }
        return v;
    }
    /**
     * @since 1.8
     */
    default boolean remove(Object key, Object value) {
        Object curValue = get(key);
        if (!Objects.equals(curValue, value) ||
            (curValue == null && !containsKey(key))) {
            return false;
        }
        remove(key);
        return true;
    }
    /**
     * @since 1.8
     */
    default boolean replace(K key, V oldValue, V newValue) {
        Object curValue = get(key);
        if (!Objects.equals(curValue, oldValue) ||
            (curValue == null && !containsKey(key))) {
            return false;
        }
        put(key, newValue);
        return true;
    }
    /**
     * @since 1.8
     */
    default V replace(K key, V value) {
        V curValue;
        if (((curValue = get(key)) != null) || containsKey(key)) {
            curValue = put(key, value);
        }
        return curValue;
    }
    /**
     * @since 1.8
     */
    default V computeIfAbsent(K key,
            Function<? super K, ? extends V> mappingFunction) {
        Objects.requireNonNull(mappingFunction);
        V v;
        if ((v = get(key)) == null) {
            V newValue;
            if ((newValue = mappingFunction.apply(key)) != null) {
                put(key, newValue);
                return newValue;
            }
        }
        return v;
    }
    /**
     * @since 1.8
     */
    default V computeIfPresent(K key,
            BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
        Objects.requireNonNull(remappingFunction);
        V oldValue;
        if ((oldValue = get(key)) != null) {
            V newValue = remappingFunction.apply(key, oldValue);
            if (newValue != null) {
                put(key, newValue);
                return newValue;
            } else {
                remove(key);
                return null;
            }
        } else {
            return null;
        }
    }
    /**
     * @since 1.8
     */
    default V compute(K key,
            BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
        Objects.requireNonNull(remappingFunction);
        V oldValue = get(key);
        V newValue = remappingFunction.apply(key, oldValue);
        if (newValue == null) {
            // delete mapping
            if (oldValue != null || containsKey(key)) {
                // something to remove
                remove(key);
                return null;
            } else {
                // nothing to do. Leave things as they were.
                return null;
            }
        } else {
            // add or replace old mapping
            put(key, newValue);
            return newValue;
        }
    }
    /**
     * @since 1.8
     */
    default V merge(K key, V value,
            BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
        Objects.requireNonNull(remappingFunction);
        Objects.requireNonNull(value);
        V oldValue = get(key);
        V newValue = (oldValue == null) ? value :
                   remappingFunction.apply(oldValue, value);
        if(newValue == null) {
            remove(key);
        } else {
            put(key, newValue);
        }
        return newValue;
    }
}
```

Map 接口处于整个框架的顶层，由一堆 Map 自身接口方法和一个 Entry 接口组成，Entry 接口定义了主要是关于 Key-Value 自身的一些操作，Map 接口定义的是一些属性和关于属性查找修改的一些接口方法。

## HashMap

见《HashMap 源码解析》

### LinkedHashMap

HashSet 有一个 LinkedHashSet 子类，HashMap 也有一个 LinkedHashMap 子类；LinkedHashMap 使用双向链表来维护 key-value 对的次序。

LinkedHashMap 需要维护元素的插入顺序，因此性能略低于 HashMap 的性能；但是因为它以链表来维护内部顺序，所以在迭代访问 <strong>Map 里的全部元素时有较好的性能</strong>。迭代输出 LinkedHashMap 的元素时，将会按照添加 key-value 对的顺序输出。

<strong>本质上来讲，LinkedHashMap = 散列表 + 双向循环链表</strong>

#### <strong>实现原理</strong>

LinkedHashMap 的主要成员变量和方法实现简化后如下：

```java
public class LinkedHashMap<K,V> extends HashMap<K,V> 
          implements Map<K,V> {
    static class Entry<K,V> extends HashMap.Node<K,V> {
        Entry<K,V> before, after;
        Entry(int hash, K key, V value, Node<K,V> next) {
            super(hash, key, value, next);
        }
    } 
    // 双向链表的头节点
    transient LinkedHashMap.Entry<K,V> head;
    // 双向链表的尾戒低钠
    transient LinkedHashMap.Entry<K,V> tail;
    // 是否按照访问顺序排序
    final boolean accessOrder;
    
    public LinkedHashMap(int initialCapacity, float loadFactor) {
        super(initialCapacity, loadFactor);
        accessOrder = false;
    }

    public LinkedHashMap(int initialCapacity) {
        super(initialCapacity);
        accessOrder = false;
    }

    public LinkedHashMap() {
        super();
        accessOrder = false;
    }

    public LinkedHashMap(Map<? extends K, ? extends V> m) {
        super();
        accessOrder = false;
        putMapEntries(m, false);
    }

    public LinkedHashMap(int initialCapacity,
               float loadFactor, boolean accessOrder) {
        super(initialCapacity, loadFactor);
        this.accessOrder = accessOrder;
    }
    
    Node<K,V> newNode(int hash, K key, V value, Node<K,V> e) {
        LinkedHashMap.Entry<K,V> p =
            new LinkedHashMap.Entry<K,V>(hash, key, value, e);
        // 将 Entry 接在双向链表的尾部
        linkNodeLast(p);
        return p;
    }
 
    @Overrid
    Node<K,V> replacementNode(Node<K,V> p, Node<K,V> next) {
        LinkedHashMap.Entry<K,V> q = (LinkedHashMap.Entry<K,V>)p;
        LinkedHashMap.Entry<K,V> t = new LinkedHashMap.Entry<K,V>
            (q.hash, q.key, q.value, next);
        transferLinks(q, t);
        return t;
    }
 
    @Overrid
    TreeNode<K,V> newTreeNode(int hash, K key, V value, 
            Node<K,V> next) {
        TreeNode<K,V> p = new TreeNode<K,V>(hash, key, value, next);
        linkNodeLast(p);
        return p;
    }
    
    @Override
    TreeNode<K,V> replacementTreeNode(Node<K,V> p, Node<K,V> next) {
        LinkedHashMap.Entry<K,V> q = (LinkedHashMap.Entry<K,V>)p;
        TreeNode<K,V> t = new TreeNode<K,V>(q.hash, q.key, 
            q.value, next);
        transferLinks(q, t);
        return t;
    }
    
    // link at the end of list
    private void linkNodeLast(LinkedHashMap.Entry<K,V> p) {
        LinkedHashMap.Entry<K,V> last = tail;
        tail = p;
        // last 为 null，表明链表还未建立
        if (last == null)
            head = p;
        else {
            // 将新节点 p 接在链表尾部
            p.before = last;
            last.after = p;
        }
    }
    
    // apply src's links to dst
    private void transferLinks(LinkedHashMap.Entry<K,V> src,
                  LinkedHashMap.Entry<K,V> dst) {
        LinkedHashMap.Entry<K,V> b = dst.before = src.before;
        LinkedHashMap.Entry<K,V> a = dst.after = src.after;
        if (b == null)
            head = dst;
        else
            b.after = dst;
        if (a == null)
            tail = dst;
        else
            a.before = dst;
    }
    
    @Override
    void afterNodeAccess(Node<K,V> p) { }
    @Override
    void afterNodeInsertion(boolean evict) { }
    @Override
    void afterNodeRemoval(Node<K,V> e) { }
}
```

LinkedHashMap 继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。

Map 类型的集合类是通过 put(K,V) 方法插入键值对，LinkedHashMap 本身并没有覆写父类的 put 方法，而是直接使用了父类的实现。

在 newNode 方法中，LinkedHashMap 创建了 Entry，并通过 linkNodeLast 方法将 Entry 接在双向链表的尾部，实现了双向链表的建立

#### afterNodeAccess()

当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。

```java
void afterNodeAccess(Node<K,V> e) { // move node to last
    LinkedHashMap.Entry<K,V> last;
    if (accessOrder && (last = tail) != e) {
        LinkedHashMap.Entry<K,V> p =
            (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;
        p.after = null;
        if (b == null)
            head = a;
        else
            b.after = a;
        if (a != null)
            a.before = b;
        else
            last = b;
        if (last == null)
            head = p;
        else {
            p.before = last;
            last.after = p;
        }
        tail = p;
        ++modCount;
    }
}
```

#### afterNodeInsertion()

```java
void afterNodeInsertion(boolean evict) { // possibly remove eldest
    LinkedHashMap.Entry<K,V> first;
    if (evict && (first = head) != null && removeEldestEntry(first)) {
        K key = first.key;
        removeNode(hash(key), key, null, false, true);
    }
}

protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {
    return false;
}
```

在元素新增之后，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。

evict 只有在构建 Map 的时候才为 false，在这里为 true。

removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。

#### afterNodeRemoval()

元素被删除后，此方法会被回调，删除双向链表中对应的节点。

```java
void afterNodeRemoval(Node<K,V> e) { // unlink
    LinkedHashMap.Entry<K,V> p = (LinkedHashMap.Entry<K,V>)e, 
          b = p.before, a = p.after;
    // 将 p 节点的前驱后后继引用置空
    p.before = p.after = null;
    // b 为 null，说明 p 是头节点
    if (b == null)
        head = a;
    else
        b.after = a;
    // a 为 null，说明 p 是尾节点
    if (a == null)
        tail = b;
    else
        a.before = b;
}
```

#### LRU 缓存

以下是使用 LinkedHashMap 实现的一个 LRU 缓存：

- 设定最大缓存空间 MAX_ENTRIES 为 3；
- 使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；
- 覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。

```java
class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private static final int MAX_ENTRIES = 3;

    protected boolean removeEldestEntry(Map.Entry eldest) {
        return size() > MAX_ENTRIES;
    }

    LRUCache() {
        super(MAX_ENTRIES, 0.75f, true);
    }
}
```

## TreeMap

TreeMap 是 SortedMap 接口的实现类。TreeMap 是一个<strong>有序的 </strong>key-value 集合，它是通过红黑树实现的，每个 key-value 对即作为红黑树的一个节点。

### 排序方式

和 TreeSet 一样，TreeMap 有两种排序方式：

- 自然排序：TreeMap 的所有 key 必须实现 Comparable 接口，而且所有的 key 应该是同一个类的对象，否则会抛出 ClassCastException 异常。
- 定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。

### 判断元素相等

类似于 TreeSet 中判断两个元素相等的标准，TreeMap 中判断两个 key 相等的标准是：两个 key 通过 compareTo() 方法返回 0，TreeMap 即认为这两个 key 是相等的；判断两个 value 相等的标准是：两个 value 通过 equals() 方法比较返回 true。

<strong>注意：</strong>如果使用自定义类作为 TreeMap 的 key，且想让 TreeMap 良好地工作，则重写该类的 equals() 方法和 compareTo() 方法时应保持一致的返回结果：两个 key 通过 equals()方 法比较返回 true 时，它们通过 compareTo() 方法比较应该返回 0。如果两个方法的返回结果不一致，TreeMap 与 Map 接口的规则就会冲突。

除此之外，与 TreeSet 类似，TreeMap 根据排序特性，也添加了一部分新的方法，与 TreeSet 中的一致。可以参考本文前面的内容。

### 实现原理

TreeMap 基于红黑树实现，而红黑树是一种自平衡二叉查找树，所以查找操作流程和二叉查找树一致。TreeMap 可保证在 log(n) 时间复杂度内完成 containsKey、get、put 和 remove 操作，效率很高。另一方面，由于 TreeMap 基于红黑树实现，这为 TreeMap 保持键的有序性打下了基础。总的来说，TreeMap 的核心是红黑树，其很多方法也是对红黑树增删查基础操作的一个包装。

# fast-fail 机制

#
