---
title: JVM 中的对象和垃圾回收
date created: 2023-03-22
date modified: 2023-03-22
tags:
  - JVM
  - 垃圾回收
  - GC
  - Java
---
# 虚拟机中的对象

了解了 JVM 运行时数据区域之后，大致明白了 JVM 内存模型的概况，对内存中的存放内容也有了初步了解。更进一步地，如果要了解内存中的数据的创建过程、在内存中如何布局、以及访问方式等，就必须要把范围限定到具体的虚拟机类型和集中在某一个内存区域上才有意义。下面以最常用的 HotSpot 虚拟机和最常用的内存区域 Java 堆为例，深入探索对象分配、布局和访问过程。

## 对象的创建

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123009.png)

虚拟机遇到一条 new 指令时，首先检查是否被类加载器加载，如果没有，则必须先执行相应的类加载过程。类加载就是把 class 加载到 JVM 的运行时数据区的过程。

### <strong>1、检查加载</strong>

首先检查这个指令的参数是否能在常量池中定位到一个类的<strong>符号引用</strong>（以一组符号来描述所引用的目标），并且检查类是否已经被加载、解析和初始化过。

### <strong>2、分配内存</strong>

如果上一步检查加载成功，接下来虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。

分配内存主要有两种方式

#### <strong>指针碰撞</strong>

如果 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“<strong>指针碰撞</strong>”。

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123013.png)

#### <strong>空闲列表</strong>

如果 Java 堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“<strong>空闲列表</strong>”。

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123019.png)

选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

如果是 Serial、ParNew 等带有压缩的整理的垃圾回收器的话，系统采用的是指针碰撞的方式，既简单又高效。

如果是使用 CMS 这种不带压缩（整理）的垃圾回收器的话，理论上只能采用较复杂的空闲列表。

#### <strong>内存分配的并发安全问题</strong>

除如何划分可用空间之外，还有另外一个需要考虑的问题是：对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的。

解决方案有以下两种：

<strong>CAS 机制</strong>

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123025.png)

对分配内存空间的动作进行同步处理，虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。虽然这种方式解决了并发问题，但是我们不难发现，这种方式增加了复杂度，降低了内存的分配的功效性。

<strong>分配缓冲</strong>

另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块私有内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer, 简称 TLAB）。JVM 在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个 Buffer，如果需要分配内存，就在自己的 Buffer 上分配，这样就不存在竞争的情况，可以大大提升分配效率，当 Buffer 容量不够的时候，再重新从 Eden 区域申请一块继续使用。

TLAB 的目的是在为新对象分配内存空间时，让每个 Java 应用线程能在使用自己专属的分配指针来分配空间，减少同步开销。

TLAB 只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个 TLAB 用满（分配指针 top 撞上分配极限 end 时），就新申请一个 TLAB。

分配缓冲较 CAS 机制少了比较、预处理，失败重试步骤，极其高效，所以我们一般使用 TLAB 方式，JVM 默认也是此方式。要禁用 TLAB，需指定 -XX:-UseTLAB。

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123030.png)

### <strong>3、内存空间初始化</strong>

内存分配完成后，虚拟机需要将分配到的内存空间（不包括对相投）都初始化为零值（如 int 值为 0，boolean 值为 false 等等）。这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

<strong>注意：此过程没有调用构造方法！</strong>

### <strong>4、设置</strong>

接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息（Java classes 在 Java hotspot VM 内部表示为类元数据）、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在对象的对象头之中。

### <strong>5、对象初始化</strong>

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但从 Java 程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，一般来说，执行 new 指令之后会接着把对象按照程序员的意愿进行初始化(构造方法)，这样一个真正可用的对象才算完全产生出来。

## 对象内存布局

在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为 3 块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。

对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

如果对象是一个 Java 数组，那么在对象头中还有一块用于记录数组长度的数据。

第三部分对齐填充并不是必须的，也没有特别的含义，它仅仅起着占位符的作用。由于 HotSpot 的自动内存管理系统要求对对象的大小必须是 8 字节的整数倍。当对象其他数据部分没有对齐时，就需要通过对齐填充来补全。数据对齐的作用就是<strong>方便进行垃圾回收</strong>。

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123035.png)

## 对象访问定位

建立对象是为了使用对象，我们的 Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。目前主流的访问方式有使用句柄和直接指针两种。

### <strong>句柄</strong>

Java 堆中会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123040.png)

- <strong>优点：</strong>reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改.
- <strong>缺点：</strong>需要在堆中维护一个句柄池，而且由于中间多了个句柄池引用过程也多了一个步骤，执行效率受到影响。

### <strong>直接指针</strong>

如果使用直接指针访问， reference 中存储的直接就是对象地址。

这两种对象访问方式各有优势，使用句柄来访问的最大好处就是 reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。

使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123100.png)

对 HotSpot 而言，它是使用直接指针访问方式进行对象访问的。

# 垃圾收集

## 判断对象存活

在堆里面存放着几乎所有的对象实例，垃圾回收器在对进行回收前，要做的事情就是确定这些对象中哪些还是“存活”着，哪些已经“死去”（死去代表着不可能再被任何途径使用得对象了）。JVM 中有两种算法判断对象的存活。

### 引用计数法

在对象中添加一个引用计数器，每当有一个地方引用他时，计数器的值就加一；当引用失效时，计数器的值就减一，任何时刻计数器为零的对象就是不可能再被使用的。

优点：原理简单、判断效率高

缺点：必须要配合大量的额外处理才能保证正确的工作，如单纯的引用计数法很难解决对象之间相互循环引用的问题。

主流的 Java 虚拟机没有采用引用计数法管理内存。

### 引用链法（可达性分析法）

#### 可达性分析

通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为 “引用链”（Reference Chain），如果某个对象到 GC Roots 间没有任何引用链相连，或者用图论的说法就是从 GC Roots 到这个对象不可达时，则证明此对象是不可能再被使用的。

主流的商用程序（Java、C#）的内存管理子系统都是通过可达性（Reachability Analysis）分析算法来判断对象是否存活。

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123106.png)

#### GC Roots 分类

作为 GC Roots 的对象包括下面几种（重点是前面 4 种）：

<strong>1、虚拟机栈（栈帧中的本地变量表）中引用的对象。比如各个现场被调用方法堆栈中使用到的参数、局部变量、临时变量等。</strong>

<strong>2、方法区中类静态属性引用的对象。比如 Java 类的引用类型静态变量。</strong>

<strong>3、方法区中常量引用的对象。比如字符串常量池里的引用。</strong>

<strong>4、本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。</strong>

5、JVM 的内部引用（class 对象、异常对象 NullPointException、OutofMemoryError，系统类加载器）。

6、所有被同步锁（synchronized）持有的对象。

7、JVM 内部的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。

8、JVM 实现中的“临时性”对象，跨代引用的对象（在使用分代模型回收只回收部分代的对象，这个后续会细讲，先大致了解概念）。

#### 决定对象是否死亡

- 可达性分析仅仅只是判断对象是否可达，但还不足以判断对象是否存活 / 死亡
- 当在可达性分析 中判断不可达的对象，只是“被判刑”= 还没真正死亡
- 不可达对象会被放在”即将回收“的集合里
- 要判断一个对象真正死亡，还需要经历两个阶段：

##### <strong>第一次标记 & 筛选</strong>

如果一个对象在可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。如果对象没有覆盖 finalize() 方法或者 finalize() 方法已被虚拟机调用过，那么虚拟机都将视为“没有必要执行”，这时对象将被继续留在“即将回收”集合。

##### <strong>第二次标记 & 筛选</strong>

如果这个对象被判断为有必要执行 finalize() 方法，那么该对象就会被放到 F-Queue 中，稍后收集器将对 F-Queue 中的对象进行小规模标记。在执行 finalize() 过程中，如果对象重新与引用链上的任意一个对象建立关系，那么第二次标记的时候就会被移除“即将回收”的集合。

经过上面两次标记 & 筛选，仍然留在“即将回收”集合里的对象将会在 GC 到来的时候被回收。

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123112.png)

<strong>尽量不要依赖 finalize，因为这个方法太不可靠，在生产中很难控制方法的执行或者对象的调用顺序。可以忽略 finalize 方法，因为在 finalize 方法能做的工作，Java 中有更好的方式，比如 try-finally。</strong>

## 引用类型

Java 中一共有四种引用，分别为强引用、弱引用、软引用和虚引用。

### <strong>强引用</strong>

一般的 Object obj = new Object() 就属于强引用。在任何情况下，只要有强引用关联（与根可达）还在，垃圾回收器就永远不会回收掉被引用的对象。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。

### <strong>软引用 SoftReference</strong>

如果内存空间足够，垃圾回收器就不会回收它，<strong>如果内存空间不足了，就会回收这些对象的内存</strong>。只要垃圾回收器没有回收它，该对象就可以被程序使用。

软引用可用来实现内存敏感的高速缓存。例如，一个程序用来处理用户提供的图片。如果将所有图片读入内存，这样虽然可以很快的打开图片，但内存空间使用巨大，一些使用较少的图片浪费内存空间，需要手动从内存中移除。如果每次打开图片都从磁盘文件中读取到内存再显示出来，虽然内存占用较少，但一些经常使用的图片每次打开都要访问磁盘，代价巨大。这个时候就可以用软引用构建缓存。

### <strong>弱引用 WeakReference</strong>

弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，<strong>不管当前内存空间足够与否，都会回收它的内存</strong>。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。

<strong>注意：</strong>软引用和弱引用可以用在内存资源紧张的情况下以及创建不是很重要的数据缓存。当系统内存不足的时候，缓存中的内容是可以被释放的。

实际运用（WeakHashMap、ThreadLocal）

### <strong>虚引用 PhantomReference</strong>

幽灵引用，最弱（随时会被回收掉）。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。唯一的作用就是垃圾回收的时候收到一个通知，可以用来监控垃圾回收器是否正常工作。

## 垃圾收集算法

#### 分代收集理论

当前虚拟机的垃圾收集器大多数都采用分代收集的理论进行设计，分代收集名为理论，实质事一套符合大多数程序运行实际情况的经验法则，，它建立在两个分代假说之上：

1. 弱分代假说：绝大多数对象都是朝生夕灭的。
2. 强分代假说：熬过越多次垃圾收集过程的对象就越难消亡。

这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将 Java 堆划分出不同的区域，然后将回收对象依据其年龄（即熬过垃圾收集过程的次数）分配到不同区域中存储。

在 Java 堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型划分；也才能够针对不同区域安排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出“标记 - 复制算法”“标记 - 清除算法”和“标记 - 整理算法”等针对性的垃圾收集算法。

一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123124.png)

- 新生代：复制算法。每次收集都会有大量对象死去，复制算法只需要付出少量对象的复制成本就可以完成每次垃圾收集。当年轻代中的 Eden 区分配满的时候，就会触发年轻代的 GC（Minor GC）。具体过程如下：

  - 在 Eden 区执行了第一次 GC 之后，存活的对象会被移动到其中一个 Survivor 分区（From 区）；
  - Eden 区再次 GC，这时会采用复制算法，将 Eden 和 From 区一起清理。存活的对象会被复制到 To 区；接下来，只需要清空 From 区就可以了。
  - 所以在这个过程中，总会有一个 Survivor 分区是空置的。Eden、From、To 的默认比例是 8:1:1，所以只会造成 10% 的空间浪费。
- 老年代：标记 - 清除或者标记 - 整理算法。老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保。对象进入老年代有多个途径：

（1）提升（Promotion）

每当发生一次 Minor GC，存活下来的对象年龄（对象头中纪录）都会加 1。直到达到一定的阈值，就会把这些“老年”对象给提升到老年代。

这些对象如果变的不可达，直到老年代发生 GC 的时候，才会被清理掉。

这个阈值，可以通过参数 ‐XX:+MaxTenuringThreshold 进行配置，最大值是 15，因为它是用 4bit 存储的。

（2）空间分配担保

GC 过程每次存活的对象，都会放入其中一个 Survivor 区，这个区域默认的比例是 10%。但是无法保证每次存活的对象都小于 10%，当 Survivor 空间不够，就需要依赖其他内存（指老年代）进行分配担保。这个时候，对象也会直接在老年代上分配。

（3）大对象直接在老年代分配

超出某个大小的对象将直接在老年代分配。这个值是通过参数 -XX:PretenureSizeThreshold 进行配置的。默认为 0，意思是全部首选 Eden 区进行分配。

（4）动态对象年龄判定

有的垃圾回收算法，并不要求 age 必须达到 15 才能晋升到老年代，它会使用一些动态的计算方法。比如，从年龄最小的对象开始累加，如果累加的对象大小，大于幸存区的一半，则将当前的对象 age 将作为新的阈值，年龄大于此阈值的对象直接进入老年代。

#### 垃圾回收类型介绍

- 部分收集（Partial GC）：指目标不是完整收集整个 Java 堆的垃圾收集，其中又分为：

  - 新生代收集（Minor GC/Young GC）：目标只是新生代的垃圾收集。
  - 老年代收集（Major GC/Old GC）：目标只是老年代的垃圾收集。目前只有 CMS 收集器会有单独回收老年代的行为。
  - 混合收集（Mixed GC）：指目标是收集整个新生代及老年代的垃圾收集。目前只有 G1 收集器有这种行为。
- 整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾收集。

#### 标记 - 清除

在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。

在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。

在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123130.png)

不足：

- 标记和清除过程效率都不高；
- 会产生大量不连续的内存碎片，导致无法给大对象分配内存。

#### 标记 - 复制

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123135.png)

将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。

主要不足是只使用了内存的一半空间。

现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间（分别叫做 From 和 To，也可以叫做 Survivor0 和 Survivor1 ），每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。

HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。

#### 标记 - 整理
![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_1231340.png)

标记的过程与“标记 - 清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

优点:

- 不会产生内存碎片

不足:

- 需要移动大量对象，处理效率比较低。

## 经典垃圾收集器

如果说垃圾收集算法是内存回收的方法论，那垃圾收集器就是内存回收的实践者。《Java 虚拟机规范》中对垃圾收集器应该如何实现并没有做出任何规定，因此不同的厂商、不同版本的虚拟机所包含的垃圾收集器都有可能会有很大的差别，不同的虚拟机一般也都会提供各种参数供用户根据自己的应用特点和要求组合出各个内存分代所使用的收集器。

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123145.png)

以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。它们之间涉及到的某些概念，在谈论垃圾收集器的上下文语境中，可以有如下理解：

- 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；
- 串行（Serial）：串行指的是垃圾收集器与用户程序交替执行，意味着在执行垃圾收集的时候需要停顿用户程序；
- 并行（Parallel） ：指的是多条垃圾收集线程并行工作，默认用户线程仍然处于等待状态。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。
- 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（不一定是并行，可能会交替执行）。用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。

#### Serial 收集器

Serial 翻译为串行，也就是说它以串行的方式执行。

它是单线程的收集器，只会使用一个线程进行垃圾收集工作。它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内。

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123150.png)

<strong>优点</strong>
简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。

<strong>缺点</strong>
进行垃圾收集工作的时候必须暂停其他所有的工作线程（Stop The World），直到收集结束。

#### ParNew 收集器

它是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123155.png)

#### Parallel Scavenge 收集器

与 ParNew 一样是多线程收集器。其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。

停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验；而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。

缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。

#### Serial Old 收集器

是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用，同样也是一个单线程收集器，使用“标记-整理”算法。如果用在 Server 场景下，它有两大用途：

- 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。
- 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。

#### Parallel Old 收集器

Parallel Scavenge 收集器的老年代版本，使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

#### CMS 收集器

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。它是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。

从名字中的 Mark Sweep 这两个词可以看出，CMS 收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：

- 初始标记： <strong>暂停所有的其他线程</strong>，并记录下<strong>与 GC root 直接相连</strong>的对象，速度很快。
- 并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段也需要<strong>暂停所有的其他线程</strong>。但停顿时间一般会比初始标记阶段的时间稍长，而又远远比并发标记阶段时间短。
- 并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123203.png)

在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。

从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：

- 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。
- 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将<strong>临时启用 Serial Old 来替代 CMS</strong>。
- 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。

#### G1 收集器

G1 (Garbage-First) 是一款<strong>面向服务器</strong>的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。

堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。它把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。

每一个 Region 都可以根据需要，扮演新生代的 Eden、Survivor 和老年代空间，G1 能够对扮演不同觉得的 Region 采用不同的策略区处理。Region 中还有一类特殊的 Humongous（巨大的） 区域，专门用来储存大对象。

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123208.png)

G1 收集器的运作大致分为以下几个步骤：

- 初始标记
- 并发标记
- 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。
- 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123216.png)

G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。

G1 被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：

- 并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
- 分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
- 空间整合：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。
- 可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。

| 收集器            | 收集对象/算法                      | 收集器类型      | 说明                                                                                                                           | 适用场景                                                                                                     |
| ----------------- | ---------------------------------- | --------------- | ------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------ |
| Serial            | 新生代/复制                        | 单线程          |                                                                                                                                | 简单高效；<br/>适合内存不大的情况；<br/>Client 场景下的默认新生代收集器。                                    |
| ParNew            | 新生代/复制                        | 并行<br/>多线程 | 是 Serial 收集器的多线程版本                                                                                                   | Server 场景下默认的新生代收集器；<br/>搭配 CMS 垃圾回收器的首选。                                            |
| Parallel Scavenge | 新生代/复制                        | 并行<br/>多线程 | 类似 ParNew，更加关注吞吐量，达到一个可控制的吞吐量；                                                                          | Server 场景多 CPU 机器上的默认收集器，主要适合后台运算不需要太多交互的任务；                                 |
| Serial Old        | 老年代/标记整理                    | 单线程          |                                                                                                                                | Client 模式下虚拟机使用                                                                                      |
| Parallel Old      | 老年代/标记整理                    | 并行<br/>多线程 | Parallel Scavenge 收集器的老年代版本，为了配合 Parallel Scavenge 的面向吞吐量的特性而开发的对应组合；                          | 在注重吞吐量以及 CPU 资源敏感的场合采用                                                                      |
| CMS               | 老年代/标记清除                    | 并行<br/>并发   | 尽可能的缩短垃圾收集时用户线程停止时间；缺点在于：<br/>1.内存碎片<br/>2.需要更多 cpu 资源<br/>3.浮动垃圾问题，需要更大的堆空间 | 重视服务的响应速度、系统停顿时间和用户体验的互联网网站或者 B/S 系统。互联网后端目前 CMS 是主流的垃圾回收器。 |
| G1                | 新生代和老年代/标记整理 + 化整为零 | 并行<br/>并发   | JDK 1.7 才正式引入，采用分区回收的思维，基本不牺牲吞吐量的前提下完成低停顿的内存回收；可预测的停顿是其最大的优势；             | 面向服务端应用的垃圾回收器，目标为取代 CMS。                                                                 |

# 内存分配与 GC 策略

## 1. 对象优先在 Eden 分配

大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。

## 2. 大对象直接进入老年代

大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。

经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。

-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。

## 3. 长期存活的对象进入老年代

为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。

-XX:MaxTenuringThreshold 用来定义年龄的阈值。

## 4. 动态对象年龄判定

虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。

## 5. 空间分配担保

在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。

如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123223.png)

## Full GC 的触发条件

对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：

### 1. 调用 System.gc()

只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。

### 2. 老年代空间不足

老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。

为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。

### 3. 空间分配担保失败

使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。

### 4. 永久代空间不足（JDK 1.8 之前）

在 JDK 1.8 之前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。

当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。

为避免以上原因引起的 Full GC，可采用的方法为<strong>增大永久代空间</strong>或<strong>转为使用 CMS 收集器</strong>。

### 5. Concurrent Mode Failure

执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123229.png)

![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123234.png)
